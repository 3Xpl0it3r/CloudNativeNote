**帧接收**

&emsp;L2的帧处理函数是由中断事件驱动的. 硬件通知CPU，该帧已经可以用了，接收中断的CPU会执行`do_IRQ`函数. IRQ对应注册的handler会被触发执行,IRQhandler会在中断模式下运行(此时其他所有的中断都会被关闭)(中断函数会执行一些立即性的任务，然后把其他任务安排到下半部函数里面执行)， 网络中断做的事情如下:
- 把帧拷贝到`sk_buff`数据结构里面
- 对一些`sk_buff`做初始化,以便在稍后上层网络使用(`sk_buff->protocol`)
- 更新其他一些设备私用参数(这些不再网络协议栈里面)

&emsp;为`NET_RX_SOFTIRQ`软IRQ调度，已准备执行 借此通知kernel有新帧

&emsp;由于设备发出的中断事件的理由各有不同(新帧已接收，帧已经成功的传输了等等)，内核的代码会配合中断通知信息(使得设备驱动程序处理例程可以按照类型处理中断事件)

## 与其他功能交互
&emsp; Netpoll 是一个通用的架构，可以通过轮询网络适配卡而传送及接收帧,把中断事件的需求删除掉了. 任何内核功能都可以使用netpoll ，以受益于其功能. 

## 设备的开启和关闭
&emsp;`net_device->state`中的`__link_state_start`标识设备被设置时候设备就被视为开启o.

## 队列
&emsp;讨论L2行为时候，帧的接收和传输都需要队列(入口队列和出口队列), 每个队列都有一个指向有关设备的指针, 以及一个指针指向存储输入/输出的`sk_buff`数据结构(只有少数设备不需要队列就可以工作例如lo设备, 因为当从回环设备传出一个包的时候，该封包会立刻被传送出去给本地系统,而不需要入排入队列里面，另外在回环设备上传出也不会有失败，所以没必要让封装重新排队队列以尝试另外一次传输),

&emsp;出口队列和设备直接相关，流量控制QOS机制会为每个设备都定义一个队列.

## 通知内核帧已经接收了: NAPI 和 `netif_rx`
&emsp;Linux驱动程序处理新帧的两种方式:
- 通过就函数`netif_rx`
> 在中断期间多帧处理
- 通过NAPI机制
> 组合模型处理


## NAPI 简介
&emsp;思想混合中断和轮询，如果有新帧进来,内核还没完成处理前几个帧的工作,那么驱动程序就没必要产生其他的中断(让内核一直处理设备输入队列里面数据会简单一点，此时该设备的功能已经关闭). 当该队列里面为空的时候重新开启中断功能。如此以来该驱动程序就能获得中断事件和轮询的优点了.
- 异步事件: 如帧的接收是由中断事件指出,如此以来，如果设备的入口队列是空，内核就不用一直去检查了
- 如果内核知道设备的入口队列中有数据存在(就没必要浪费事件去处理中断),简单轮询就够了.
&emsp;NAPI的优点:
- 减少了CPU的负载(因为中断变少了)
- 设备的处理更为公平
> 一些设备的入口队列中如果有数据，就会以相当公平的循环方式来访问。这样确保当其他的设备的负载很高时候，低流量的设备所体验到延时仍在可接受范围内

## NAPI 用到的`net_device`字段
&emsp;为了处理驱动程序使用的NAPI 接口设备，有四个新字段,以供`NET_RX_SOFTIRQ`软IRQ使用,其他设备不会用到这些字段,但是他们可以共享嵌入到`softnet_data`结构中作为`backlog_dev`字段的`net_device`结构体字段
- `poll`:
> 这个寻函数可以用于把缓冲区从设备的输入队列里面退出。这个队列使用NAPI设备的私有队列，而`softnet_data->input_pkt_queue`供其他设备使用
- `poll_list`:
> 这是设备列表,其中的设备就是在入口队列中有新帧等待被处理的设备。 这些设备处于轮询状态
- `weight`, `quota`
> `quota` 是一个整数，代表的是poll虚拟函数一次可以从队列推出的缓冲期的最大数目.其值的增加以weight为单位，用于不同设备之间增加某种公平性。配额越低表示潜在的延时越低，因此让其他设备饿死的风险越低。另外方面低配额会增加设备之间切换的数量，因此整体的损耗会增加.

## `net_rx_action`和`NAPI`
&emsp;`net_rx_action` 是`NET_RX_SOFTIRQ`标识相关联的函数.当帧进来的时候.触发了`net_rx_action`执行, `net_rx_action`会浏览列表中处于轮询状态的设备,然后为每个设备调用想关联的poll虚拟函数,用来处理队列中的帧(每次poll启动的时候，能处理的帧数都与最大值的存在). 如果在其时间片段内无法使得队列清空,就等到下一个时间片段继续下去.也就是`net_rx_action` 会持续为入口队列中有数据的设备调用其设备驱动程序所提供的poll方法, 直到入口队列为空.到那个时候就不在用轮询了. 而设备驱动程序就可以重新开启设备中断通知功能. 值得强调的是，中断功能关闭只针对那些在poll_list中的设备. 也就是只用于那些使用NAPI而不共享backlog_dev的设备


&emsp;`net_rx_action` 会限制其执行时间,当其用完限制的执行时间或者处理过一定数量的帧后,就会自行重新调度以准备执行,这样为了强制`net_rx_action`能与其他kernel任务彼此公平运行. 同时每个设备也会限制其poll方法每次启用时所能处理帧数目，才能与其他设备之间彼此公平运行.当其他设备无法清空其入口队列时候就会等到下次的调用poll方法


&emsp;`NAPI`和非`NAPI`区别:
- `NAPI`必须提供一个`poll`方法
- 传统的则是调用`netif_rx`方法



