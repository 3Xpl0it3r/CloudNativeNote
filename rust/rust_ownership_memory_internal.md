&emsp;从一个例子开始，看下下面的代码:
```rust
let a: String = "hello workd".to_string();
let b: String = a;
```
QA: `a`和`b`的变量最终的值是多少？
&emsp;上面例子通常再有gc的语言里面根据具体的类型，这种赋值操作会有两种不同的事情. 对于基础类型，上面的例子会单纯的把`a`里面的值直接拷贝到`b`里面，对于复合类型，上面的例子会将`b`指向`a`,所以他们内部共享了相同的数据.

&emsp;但是这个在rust里面却不一样。上面代码片段`a`会被移动到`b`,然后`a`会被释放掉,再也不会存在，也不存储任何数据了。

&emsp;默认情况下，rust会使用move来代替copy。这就意味着rust会逐个字节的copy数据，然后移除掉原始的副本，把内存归还给操作系统。当然也有特殊例子，对于基础类型，它会copy内容，而不会移除原始版本.



**内存指针**
&emsp;你也许会思考这些值在内存里面是如何布局的？对于不同的类型他们的组织方式有舍区别。程序是如何区分两个变量的。
&emsp;内存可以被看成一个数组，容量大约在2^64
```rust
let mem: Vec<u8> = vec![0; 18_000_000_000_000_000_000];
```
(Node: 上面语法是rust创建一个vector，里面每个元素是u8类型，总共有18000000.个元素，每个元素初始化为0)

&emsp;当你声明一个变量的时候，程序需要决定将这个变量放在这个内存list里面哪个位置。 变量要是在这个list里面的位置，就代表了它对应的内存地址。当然我们可以把另外一个地址的索引存放到这个list里面，这个就是指针(通常用 & 符号来取地址), 通常内存地址是十六进制表示

&emsp;例如我们想要把`a`这个变量存储在`0x100`这个地方，我们就可以编写如下语句
```rust
let p_a: &i32 = 0x100;
let a: i32 = *p_a;
```
&emsp;上面只是一个虚构例子，在这个例子里面`*p_a`和`mem[p_a]`是等价的。因为内存访问最小单位是字节，而这个变量有4个字节，因此它需要读取四个索引，因此有时候可以写成下面这样:
```rust
let a: i32 = mem[p_a] << 24 + mem[p_a+1] << 16 + mem[p_a+2] << 8 + mem[p_a+3] << 0; 
```
 注意的是，在这个例子里面我们将第一个字节对应这个这个整数的高位地址(这个取决于处理器的实现)，当然这些细节由程序语言完美的给处理了，包括rust，c/c++。有些操作甚至直接在处理器内部就被完成了。

 &emsp;当然我们在写rust/c的时候不需要这样的编码，但是理解这些有助于我们理解这些编程语言背后的设计理念，特别是没有gc的语言。

 &emsp;现在我们有一个4个byte的变量。当我们存放另外一个8个byte的时候变量的时候会发生什么呢？考虑下面的例子
 ```rust
 let p_a: &i32 = 0x100; // 原始变量
 // ---
 let p_b: &i64 = 0x102;
 let p_c: &i64 = 0x0FA;
 let p_d: &i64 = 0x106;
 ```
 &emsp;针对上面三个例子，他们都有一些问题，他们都存放的是8字节的变量。`p_a` 会占据`0x100, 0x101, 0x102, 0x013`四个内存空间，这就意味着`p_b` 会覆盖`p_a` 两个字节的地址。`p_c`同样也有问题，`p_d`不存在这样的问题，可以work，但是它的问题在于会造成内存碎片。通常情况下，操作系统和编译器都希望内存尽可能的打包在一起，减少内存之间的空隙。


**关键点-1**
- 内存是一个扁平的字节list。
- 指针在任何编程语言内部都随处可见
- 编译器必须知道一个变量在内存里面占据多大的位置，以便他们可以正确的读写
- 大端还是小端存储这个在手动操作内存是非常重要的(但是几乎不需要手动去操作内存)


**虚拟内存和初始化**
&emsp;现在让我们返回内存例子：
`let mem: Vec<u8> = vec![0, 18_000_000_000_000_000_000];`
你也许会很好奇，这个例子里面给这个vector64个元素，这个几乎比任何实际中机器的内存都要大。(几乎，因为有些内存地址会被保留)

&emsp;或者换另外一个问题更好，不同的程序他们都运行在同一个内存空间里面么？在这种情况下，一个程序需要避免和另外一个程序产生冲突(上面例子的变量覆盖问题)； 答案通常是否定的，但是取决于具体情况。事实上程序里面看到的`0x100`并不是实际物理内存的地址。这个是虚拟内存方便的东西，在一个x86_64机器上，一个程序能看到的内存大小是2^64字节，即使机器只有4个G的内存空间。（不考虑特殊的操作系统)

&emsp;下面一个问题就是：在内存里面变量会不会被初始化，或者你认为的是会被初始化为0或者一些过时的数据？事实上都有可能，这个取决于操作系统和它的具体配置。所以永远不要假设数据会被初始化为0或者是垃圾数据。初始化为0是为了避免将内存信息泄漏给其他的程序。 大部分的gc语言例如go语言会讲内存初始化为0.大部分的非gc语言例如c/c++,rust会原封不会的保留为初始化的内存信息，这个需要人为手动的去初始化它。


&emsp;rust其实是允许读取未初始化的内存的，但是仅限于`unsafe`。这个主要是为了避免在一些复杂的算法里面初始化两次。 c/c++,rust都比较相信程序员知道他们自己在做的事情，但是和c/c++不同都时候，rust有很多的安全策略，而c/c++则需要程序员时刻小心谨慎。(当然rust也提供了unsafe编程，但是这个仅针对专家级别的)

**关键点-2**
- 程序运行在虚拟内存里面(虚拟内存比实际内存大得多)
- 内存通常不会被初始化，里面是一些随机的数据，但是有些操作系统会为了安全考虑初始化掉内存
- 编程语言一般要么初始化内存(一些gc语言)，要么阻止你读取未初始化的内存(safe-rust)


**内存分配和释放**
&emsp;这是讨论内存的最后一个topic。， 假设你写了下面的代码:
```rust
let p_a: &i32 = 0x100;
let a:i32 = *p_a;
```
上面代码其实在rust里面是无法工作的，对应的c代码如下:
```c
int &p_a = 0x100l
int a = *p_a;
```
&emsp;rust是不允许我们直接操作内存的(除非我们使用unsafe)。对应的c代码即使可以编译，它也是不work的。

&emsp;主要原因是`p_a`指向了一个未分配的内存(未分配的内存和未初始化的内存不是一个概念);程序是无法读取任何指向未分配内存的地址的。这个是y由os来保证的。在c里面可以通过`alloc/malloc`来分配内存.当一个程序申请一段内存的时候它不需要具体指派内存地址，只需要告诉操作系统我需要多大的内存就可以了。 这个地址是由操作系统分配的，程序无法干预。
```c
let &p_a = (int*)malloc(sizeof(int));
```
&emsp;内存在分配后就可以被读写了，但是需要注意的是，具体的内存里面的内容是什么我们不清楚，这个取决于操作系统(除非我们手动的去初始化)。

&emsp;当我们利用完了这段内存，并且不在需要它的时候，我们需要释放掉它，并且把它归还给操作系统(这相当于告诉操作系统，这段内存我已经用完了，你可以回收了给它程序用了)。如果我们不去释放它，那么就会造成内存泄漏问题。

&emsp;在rut里面我们不需要担心内存的分配和释放问题了，因为rust已经帮我们管理了。我们不太需要担心内存泄漏的问题了，除非因为结构递归的问题，当然这个在其他任何gc里面都会有这样的问题。这个和c语言是有点不一样的，在c语言里面我们需要手动的释放它`free()` ，当然在rust里面我们可可以手动的去释放`drop(a)`; 之前已经提到了在rust里面其实不太需要关注这个，当然如果想要提前释放的话。(在其他类似c语言里面，这个里面处理不当还会有二次释放的问题)


**关键点-2**
- 在内部，内存的使用是需要向操作系统申请，不用的时候需要归还给操作系统的。
- 程序无法决定被分配的地址
- 内存释放是必要的，这样可以避免内存泄漏的问题，在rust里面这个rust已经帮忙做了
- rust里面尽量别用unsafe，unsafe是为专家准备的


**Stack 和 Heap**
&emsp;之前提到的内存分配/释放都是针对heap。当然还有stack内存空间，这里不打算探讨他们区别。 在rust里面主要倾向于基于作用域来自动分配/释放内存来避免gc.。 rust会将一部分的数据放在heap上面，并且大部分的是变量放在stack上面。例如`Box<T>`会把数据存放在heap上面。

**复合类型在内存里面布局**
&emsp;探讨下复合类型内部在内存里面是如何布局的。， 在c/c++里面一个对象看起来像下面这个样子:
```cpp
class Card {
public:
    int number;
    int suit;
};
int main(){
    Card aceOfSpades;
    aceOfSpades.number = 1;
    aceOfSpades.suit = 4;
}
```
在rust里面如下:
```rust
pub struct Card{
    pub number: i64,
    pub suit: i64,
}
fn main(){
    let ace_of_shades = Card{
        number:1,
        suit: 4,
    };
}
```
其他语言类似python 
```python
class Card:
    number: int 
    suit: int
ace_of_shades = Card
ace_of_shades.number = 1 
ace_of_shades.suit = 4
```
&emsp;其他语言基本类似，但是注意大多数语言其实都是允许我们先创建对象，而不需要对对象里面的内存具体先赋值，因此我们后续可以对对象里面内容在做修改。在rust不行，还记得之前内存初始化里面谈及到的，c++,go(或者大部分的语言)都会将分配的内存直接初始化为0，因此这就意味着我们在创建对象的时候指定他们具体的值的时候，其实是对这个对象里面的字段做了两次赋值。 这种事情在大部多数语言里面通常都不是性能的问题，而是缺少穷举性：如果你忘了给某些变量定义一个值，那么它默认会给你初始化为0，编译器不会给你任何警告(可能这个0并不是我们期望的，这个在后续就很难debug)。但是这个在rust里面是不允许发生的。

&emsp;现在我们回归到最初的问题，那么这样一个复合类型在内存里面是如何布局的呢。 很简单，它使用了16个字节空间，前8个字节存储`number`, 后8个字节存储`suit` 连续的16个字节，看起来非常好， 这个对象在编译期间就已经知道大小了，这就意味着:
```rust
&ace_of_shades.suit = (&ace_of_shades+ 8)
```
&emsp;现在让我们讨论下strings类型，string类型是多大呢？如果编译器要去读取string，那么它该从内存里面读取多少个字节呢？现在的问题是string是可以任意大小的。它的大小可以是一个空的字符串，也可以是在一个变量里面存储一本书的内容., 那么该如何存储他们呢？在C语言里面，string可以通过终止符0x00来分割，因此函数必须要一直的读，直到检测到这个终止字符为止。但是这个有个缺点，如果在你字符串中间有个`\0`， 那么你可能就不能完整的读取他们了。在rust里面一个string类型他有一个指向数据底层的指针，和一个他的长度。
```rust
pub struct String {
    buf: *mut u8,
    len: usize,
}
```
> 需要注意的时候，String在rust里面和Vec<u8> 类型是一样的，但是Vec 本身使用了类似的机制，在这里我故意忽略它的容量，容量会占8个字节。
&emsp;这种结构就可以使得string变得sized，在64机器上面，他有16个字节的长度，忽略string本身的内容，它的长度基本是固定的。当然这并不意味着它永远占据16个字节，很显然保存文本的内存仍然要被使用，但是他们存储在另外的地方。和C语言相比它几乎没啥缺点，除了它会浪费16个字节，而c语言只需要浪费1个字节。

&emsp;那么方法呢？方法/函数在代码段。

**关键点**
- 对象通常存储在内存里面，通过字段来链接他们。
- 对象也可以存储指向内存里面的一个地址
- 方法在object里面不会占据空间


**OwnerShip**
&emsp;Ownership这个也许是rust里面最重要的一个概念了，想象下，当我们在一系列函数之间传递数据。那么这个数据应该在哪个地方被分配内存，在哪个地方被释放内存。在gc语言里面gc会帮我们做这些事情，但是这个会消耗一些时间周期。C/c+ 有个很酷的方式，那就是利用stack和scope。例如下面的代码
```c
int main()
{
    Card aceOfSpades;
    aceOfSpades.number = 1;
    aceOfSpades.suit = 4;
}
```
&emsp;上面变量aceOfSpades 会被自动创建，当离开作用域的时候会被自动释放，cool？对于这样简单的例子，C 自动帮我们管理了内存。如果这种简单的例子可以扩展到其他任意的场景下面，那么就很好了，因为对象会在最里面的函数被丢弃掉。如果一个函数能够在使用数据之后是否要释放数据，那么就更好了。但是问题是如果一个函数释放了数据，但是有其他调用者期待这个数据仍然存活。那么就会有报错。

&emsp;但是这个在c++里面是很难的一件事情，有些人可能使用函数命名模式来传达这一点，或者直接干脆全部clone/copying 来代替传递指针来避免风险。
&emsp;在rust里面，这个是由编译器来强制，编译器通过追踪谁拥有这个数据，对数据拥有所有权的那个变量负责数据的释放，要保证在任意一个时间点只有一个owner，如果不是，那么就有可能会有多次释放的危险。在rust里面当你创建了一个变量，那么你就拥有了这个变量
```rust
fn main(){
    let ace_of_shades = Card{
        number: 1,
        suit: 4,
    };
}
```
在这里，main owns ace_of_shades, 并且他在最后需要负责这个数据的释放，因此在代码的末尾有一个隐式的`drop(ace_of_shades)`
&emsp;目前为止这个基本上和其他语言没有啥区别，但是rust有个很酷的功能，那就是wonder是可以转移的。
```rust
fn main(){
    let ace_of_shades = Card {
        number: 1,
        suit: 1,
    }
    print_card(ace_of_shades);
}
fn print_card(card: Card){
    println!("Number: {} Suite: {}", card.number, card.suit);
}
```
&emsp;现在在上面的例子里面`print_card`就接受了Card的所有权，并且在他函数的最后会释放掉它，这就意味着main不在需要负责释放他的内存了。但是，rust是如何知道在函数的最后他应该要释放掉内存，因为这个函数接受的是`Card`而不是`&Card`或者`&mut Card`， 如果你看到的是完整的类型，而不是有个&， 那么它就对这个值是拥有所有权的。对于`&Card`和`&mut Card`这两种意味着函数对指向这段内存空间的地址拥有所有权，而不是指针指向的内容拥有所有权。相同的形式，`Rc<T>`或者`Box<T>`这样的参数，那么函数拥有的所有权属于外部的Rc或者Box,但是里面的行为怎么样取决于具体的类型。

&emsp;当我们不想要这个类型被drop掉呢，有两种类型，第一种改变接受者，接收一个借用的对象，或者在发送数据之前拷贝一份，类似`print_card(card.clone())`;， 在rust里面我们需要实现clone这回trait或者单纯的在structure上面加个`#[derive(Clone)]`来实现默认的copy行为，默认的copy会拷贝所有的数据。所以我们可以看到在rust里面默认的行为是move， 而在C++里面默认的行为是copy。如果我们在rust里面不想要在内部函数里面， 那么就需要在card前面增加一个&符号，`fn print_card(card: &Card){}` .这个是告诉编译器，它不拥有这个数据，它无权释放数据，这个时候`card`就会被当成一个指向`Card`数据的指针，当丢去这个变量的时候，它丢弃的时只是指向底层数据的指针。其余的代码不需要做任何的改动个。

&emsp;通过这些简单规则rust很容易可以做出决定他应该在什么时候分配内存，什么时候清理内存，我们只需要关系owner和borrow， 但是这些是有编译器来检查的，没有办法去欺骗他。当然还有个比较不好的方法，通过返回所有权来达到这个效果
```rust
fn main(){
    let ace_of_shades = Card{
        number: 1,
        suit: 1,
    };
    let ace_of_shades = print_card(ace_of_shades);
}
fn print_card(card: Card) -> Card {
    println!("Number: {} Suite: {}", card.number, card.suit);
    card
}
```
&emsp;上面的例子有点滑稽，其实可以依赖编译器来避免这种二次移动，其次这个在rust里面是一种反模式，这种弊大于利，往往会带来更多的问题。根据一般经验来看，如果你不需要在你的函数里面释放这个对象，那么就最好不要获取他的所有权。

&emsp;ownership和borrowing 我们可以看成是rust里面的权限系统(这里权限不是用户权限,不是读写权限，是编译器/内存管理权限， 有没有权利去释放资源, mut 控制读写权限）

- Ownership 拥有最高权限，(在内部函数里面依旧不可以修改)
- &mut: 第二权限, 可以修改内容，但是不能释放内容
- &  最低权限, 只能读，不能改，更不能释放
> 有一点需要注意的是，其他人可以对borrow做copy操作。例如一个函数需要对&Card做修改，那么可以先copy，在修改copy的数据。
```rust
fn main(){
    let ace_of_shades = Card{
        number: 1,
        suit: 1,
    };
    let ace_of_shades = print_card(ace_of_shades);
}
fn print_card(card: Card) -> Card {
    println!("Number: {} Suite: {}", card.number, card.suit);
    let mut next = card.clone();
    next.number += 1;
    next
}
```
&emsp;这套体系的比较好的在于开发人员一开始就会知道函数是不是会对我们传入的数据做修改。

**关键点**
- 正常在rust里面通常是owner的，除非在类型前面加&和&mut 。
- ownership 意味着在对象离开作用域后，它有权释放这个对象
- 一个对象永远有且只有一个对象。
- copy和clone和其他语言里面的实现是一样的，没有其他花里花哨的东西
- borrow是两个函数共享对象一个非常好的办法，如果我们不希望在使用后释放它的话。
- 当我们创建一个函数的时候，我们优先考虑用最低权限
- 我们永远可以修改一个数据的副本。是不是需要修改原始数据我们需要小心，也许不需要。


**Copy Types**
&emsp;在rust里面，copy是有着特殊含义的，你也许会注意到当我们讨论copy和clone的时候我们是把他们当作两件不同的事情来看待的。其实在rust里面他们本来就是两件不同的事情，copy是逐字节拷贝的，而clone则是由用户自定义来实现的。下面我们先只关注copy，先忘掉有clone这个玩意。
&emsp;让我们考虑下面这个例子：card在内存里面的layout如下
```txt
|-------------------------------------------------------------------------------|
|                       ace_of_shades                                           |                                   
| 00 | 00 | 00 | 00 | 00 | 00 | 00 | 01 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 04 |
|                    number             |           suit                        |
|_______________________________________________________________________________|
```
&emsp;copy意味着我们程序会从内存里面读取这些字节，然后把他们放在另外一个地方。在拷贝的那一刻，它不在意它是card还是其他什么，它只是一个需要被拷贝到其他地方的大小是16个字节的数据.
&emsp;那么现在的问题是，这种copy是不是总是work的，总是保持数据的准确性。
&emsp;对于常规的value，例如number或者char类型，它无疑是正确的，那么对于内存地址呢？如果它包含了一个内存地址，那么它会发生什么？如果这个指针是一个共享只读的borrow，那么它不会有任何问题，我们可以有任意多的reader，它仍然工作的非常好(因为指针指向的内存不会变)， 所以它一定是work的。

&emsp;对于可变的借用，唯一的问题就是会有多个读写指针指向同一个内存地址(这个会造成数据竞争)，除此之外没有其他的问题，这个指针仍然是合法的。但是rust不允许复制可变的借用，以便防止打破规则。
&emsp;因此在rust里面存在着一种状况，有些数据可以copy，有些数据不允许copy。但是。。。有一种可能那就是指针本身就是结构体的一个对象(结构体拥有对该指针的所有权)， 例如下面:
```rust
pub struct String{
    buf: *mut u8,
    len: usize,
}
```
&emsp;buf 实际所有权归属于String，当创建一个新的String的时候，内存会随着buf被保留，当String被释放掉的时候，buf 里面的内容也会被释放掉。我们也许会猜测这个可能是rust编译器帮我们做的这些事情，那么我们可以人为的来完成这些事情么？

&emsp;上面问题答案是yes,这个主要是由`Box<T>`来完成的，这种结构一般用来存储指向一个内存位置的指针(或者存储一个相同结构的指针)。例如下面例子:
```rust
pub struct HandOfCards{
    card1: Box<Card>,
    card2: Box<Card>,
    card3: Box<Card>,
    card4: Box<Card>,
    card5: Box<Card>,
}
```
&emsp;上面这个例子并不是一个实际的例子，只是拿来演示，在这个例子里面`Card`内存需要被提前分配，在我们创建HandOfCards，当HandOfCards 退出作用域的时候，Card也会被释放掉。如果我们存储在vec里面，vec 机制和box差不多，当vec被释放的是时候，card也会被释放掉。

&emsp;现在我们开始返回Copying，如果我们尝试copystring这个结构体，那么问题是我们拷贝是指针，而不是里面实际的内容，这就意味着实际的数据有两个指针同时指向它， 这个不仅是破坏这个规则，同时还是带来二次释放的问题，因为box被释放掉的时候， box<T> 里面的数据也会被释放。

&emsp;那么哪些数据是可以被copy的？ 只有实现了`Copy`这个trait的类型才可以被copy，如果string结构体实现了copy这个trait，那么他也是可以copy的。`impl Copy for Card{}`, 现在这个结构体就可以被copy了，这个是rust帮忙我们做的，我们不需要考虑，这个类型可以copy的唯一的方式，当然我们通常使用下面的写法:`#[derive(Copy)]`这种写法


**关键点**
- copy 在rust只是byte by bytes, 它不回去试图理解类型的内容。
- 内存在某些情况下会阻止copy，因为结构体里面某些字段会禁止它们被copy。
- 不可变借用是可以copy的，可变借用rust则不允许
- 如果有可能则尽量实现copy这个trait，因为它会使得你更容易编写一些东西



**copy和clone的异常**
&emsp;一开始讨论copy的时候提到暂时忽略clone。当我们在谈到clone的时候这个里面会有一些小问题。
&emsp;首先对于c++来将它不总是回去clone，clone对于c++来讲是deep copy。对于简单的类型，它默认就是copy，对于复杂的类型，则取决于它具体的实现。clone有很多弊端，首先它会浪费很多的周期，对于简单的类型它和copy没啥区别对于复杂的类型，它会浪费更多的资源(cpu/内存),. 和copy一样，想要clone则需要实现clone这个trait

&emsp;通过传递引用，而不是传递值，则会帮我们减少不必要的copy。总是clone和copy也会带来一些问题，比如你想要改变一个值，但是你把这个改动写到了一个你不期望的副本里面。在这种情况情况下可以使用`&mut`或者`Rc<T>`也许会帮助到你。

&emsp;在某些情况下实现copy不是一个好注意，它会引起一些意想不到的意外。例如当你创建了一个迭代器，你可能会以不同的迭代器结束，而不是一开始的那个迭代器。故意不对这些类型实现copy，这种作者向我们传达这些类型应该如何被合理使用的一种方式。

&emsp;copy rust编译器会帮我们做，clone需要自定义，在合适的情况下使用clone/copy。



**move 语意**
&emsp; 在rust里面。所有的类型都是可move的，move这意味着只要最初的版本被销毁，创建的副本就必须有效。这就意味着我可以获取任何类型，然后通过copy数据的方式将它的内存地址从0x100改变成0x200,然后移除它原始的版本，它应该还是正常的work的。当然这个前提是这个类型里面没有指向初始数据的指针，否则就会造成悬浮指针的问题，这就意味着这个类型里面没有借用，无论是可变还是不可变的。也就是说如果需要移动，必须要有所有权。

&emsp;当然也有特例情况，`std::mem:swap`这个方法接受两个&mut 指针，然后移动它们的数据，当然对于同一个类型的两个实例，切换它们的内容这个就应该是合理的。

&emsp;问题来了，对于所有任何类型这个都是work的么？我们可以放任何类型在structure里面，它仍然work么？，几乎， 当然有一种情况下它会失败， 如果你构建了一个自引用的结构体，那么它就会失败。
&emsp;例子如下，假设你有个结构体，里面有个字段有自己数据(ownership),但是通过一个指向其成员的指针给用户爆漏一个只读接口，这个接口主要防止别人不经过某些方法而直接修改它。
```rust
struct MyData {
    buf: Vec<u8>,
    pub buffer: &Vec<u8>, // this is always point to &buf
}
```
这个结构体只要移动，就会被破坏掉。当他移动的时候，MyData的内存地址就会被移动，那么buffer就会指向一个过时的地址，这个显然是有问题的。(NewMyData.buffer = &OldMyData + 0, 而这个地址是非法的。),这个变量依赖这个结构体在内存的位置。

正因为这个原因，rust是不允许在structure里面构建自引用的。这个是通过borrow lifetime来禁止的， 你需要在structure生命周期里面保证它的存在，但是又不能通过这种方式将它和结构体生命周期绑定起来。
如果非要这么做，可以通过在一个方法里面返回一个borrow pointer来做到这个效果，而不需要通过将指针存储到内存里面这种方式

在rust如果代码有可能是不安全的，那么rust就不支持。除非通过unsafe来做，unsafe里面有个Pin的东西(pin不翻译，这个我也不懂，这个是给专家保留的，别用unsafe) 。

**关键点**
- rust里面所有的type都是可move（move意味着改变它们自身的内存地址）
- mem:swap 可以用于两个&mut指针(因为正常的move必须要有ownership)
- self-referential 不支持，在安全的rust里面， 除非用unsafe
- 当然避免它们可以通过Rc<T> 来做到。
