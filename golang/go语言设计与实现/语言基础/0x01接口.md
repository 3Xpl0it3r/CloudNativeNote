
&emsp;在go里面，接口是一组方面的签名，常见问题


#### 0x00 概述
&emsp;接口是计算机里面多个组件共享的边界，不同的组件能够在边界上交换信息。接口的本质是引入一个新的中间层，调用方可以通过接口与具体接口实现分离，解除上下游的耦合，上下模块不在需要依赖下层的具体模块，只需要一个约定好的接口
&emsp;和其他语言里面显示接口不一样，例如在rust里面一个接口定义如下:
```rust
trait MyInterface {
    fn InterfaceFunc(&self);
}

struct MyStruct {}

// 为一个类实现接口
impl MyInterface for MyStruct {
    fn InterfaceFunc(&self) {}
}
```
go里面接口定义如下:
```go
type error interface{
    Error() string
}
// 一个自定义的类型
type RPCError struct {}
// RPCError  需要实现error的接口
func(e *RPCError)error()string {
    return "this is rpc error"
}
```
- 在类似java，rust语言里面，接口需要显示的声明接口并实现所有方法， 
- 在go里面，实现了接口的所有的方法，就隐式的实现了接口
&emsp;上面RPCError 结构体其实并不关心它自己实现了哪些接口，go语言只会在传递参数/返回值/变量赋值的时候才会对某个类型是否实现了接口进行检查
```go
type RPCError struct {
	Code    int64
	Message string
}

func main() {
	var rpcError error = NewRPCError(400, "unknown error") // 类型检查1
	err := AsErr(rpcError)                                 // 类型检查2
	println(err)
}

func (e *RPCError) Error() string {
	return fmt.Sprintf("%s, code=%d", e.Message, e.Code)
}

func NewRPCError(code int64, msg string) error {
	return &RPCError{Code: code, Message: msg} // 类型检查3
}

func AsErr(err error) error {
	return err
}
```
&emsp;go语言会在编译期间对代码进行类型检查，上面的代码总共出发了三次类型检查
- 将`*RPCError` 类型变量赋值给`error`类型变量的时候，`rpcErr`
- 将`*RPCError` 类型变量`rpcErr`传递给签名中参数为`error`的`AsErr`函数
- 将`*RPCError` 类型的变量从函数签名的返回值为`error`的`NewRPCError`函数中返回
&emsp;从类型检查的过程看，编译器尽在需要的时候才会检查类型，类型实现接口的时候只需要实现接口里面所有的方法，而不需要像java/rust等编程语言里面一样显示的声明。

**类型**
&emsp;接口也是go语言中 的一种类型，它能够出现在变量的定义，函数的入参，和返回值里面，并对他们进行约束，在go语言里面主要有两种略微不同的接口。一种是带有一组方法的接口，另外一种不带任何方法的接口
- runtime.inface: 在go里面使用iface来表示第一种接口
- runtime.eface: 在go里面使用eface表示不带有任何方法的接口
> 两个接口虽然都使用了interface 声明，但是后者在go里面也很常见，所以在实现的时候使用了特殊的类型， 注意和c语言里面的`void*`不一样，`interface{}`并不是任意类型。如果我们将类型转换成`interface{}`类型，变量在运行期间的类型也会发生变化，获取变量类型的时候也会得到`interface{}`
```go
func main() {
	type Test struct{}
	v := Test{}
	Print(v)
}

func Print(v interface{}) {
	println(v)
}
```
&emsp;上面函数不接受任意类型的参数，只接受`interface{}`类型的值，在调用`Print`函数时候会对`v`进行类型转换，将原来的`Test`类型转换成`interface{}`

**指针和接口**
&emsp;在go语言里面使用指针和接口时候会发生一些让人困惑的问题，接口在定义一组方法的时候没有对实现的接受者坐限制，所以我们会看到某个类型实现接口的两种方式
```go
type Duck interface {
	Walk()
	Quack()
}

type CatV1 struct{}

func (c CatV1) Walk()  {}
func (c CatV1) Quack() {}

type CatV2 struct{}

func (c *CatV2) Quack() {}
func (c *CatV2) Walk()  {}
```
&emsp;这是因为结构体类型和指针类型不一样，就像我们不能向一个接受指针的函数传递结构体一样，在实现接口的时候，这两种类型也不能划等号。上面两种方式是不可以同时存在的。go语言编译器会在结构体类型和指针类型都实现的时候报错`method redeclared`

&emsp;对`Cat`结构体来说，它在实现的时候是可以选择接受者的类型，即结构体或者结构体指针，在初始化的时候也可以初始化成结构体或者指针。下面代码总结如何使用结构体，结构体指针实现结构，以及如何使用结构体/结构体指针初始化变量:
```go
type Cat struct {}
type Duck interface{...}

func(c Cat)Quack(){} // 使用结构体实现接口
func(c *Cat)Quack(){} // 使用指针实现接口

var d Duck = Cat{} // 使用结构体初始化变量
var d Duck = &Cat{} //使用结构体指针初始化变量
```
&emsp;实现接口的类型和初始化返回得了类型两个纬度组成了四种情况
||结构体实现接口|结构体指针实现接口|
|----|----|----|
|结构体初始化变量| 通过| 不通过|
|结构体指针初始化变量| 通过 | 通过|

&emsp;四种里面只有使用指针实现接口，使用结构体初始化变量的无法编译通过的。
&emsp;那么剩下的两种方式为什么一种能够通过编译，另外一种无法编译通过呢。我们先看下第一种能够通过编译的情况，即方法的接受者是结构体，而初始化的变量是结构体指针
```go
type Cat struct{}
func(c Cat)Quack(){
    fmt.Println("meow")
}
func main(){
    var c Duck = &Cat{}
    c.Quack()
}
```
&emsp;作为指针的`&Cat{}`变量能够`隐式`的获取到指向的结构体，所以能够在结构体里面调用`Walk`和`Quack` 的方法，我们可以将这里调用理解成为C语言里面`d->Walk()` 和`d->Speak()`，他们都会获取指向的结构体，然后再去执行对应的方法。
```bash
➜  语言基础 git:(master) ✗ cat main.go
package main

import "fmt"

type Duck interface {
	Quack()
}

type Cat struct{}

func (c *Cat) Quack() {
	fmt.Println("meow")
}

func main() {
	var c Duck = Cat{}
	c.Quack()
}
➜  语言基础 git:(master) ✗ go build main.go
# command-line-arguments
./main.go:16:6: cannot use Cat{} (type Cat) as type Duck in assignment:
	Cat does not implement Duck (Quack method has pointer receiver)
➜  语言基础 git:(master) ✗
```
&emsp;编译器提示我们`Cat`类型没有实现`Duck`接口，`Quack`方法的接受者是指针。 go语言在传参的时候都是传递值的
- 对于`&Cat{}`来说，这意味着拷贝一个新的`&Cat`指针，这个指针和原来的指针指向同一个相同的并且唯一的结构体，所以编译器可以隐式的对变量解引用(dereference)获取指向指向的结构体。
- 对于`Cat`来说，这意味着`Quack`方法会接受一个全新的`Cat{}`，因为方法参数是`\*Cat`， 编译器不会无中生有创建一个新指针，即使创建了一个新指针，对新指针解引用后指向的也不是最初调用该方法的结构体。
&emsp;上面只是解释指针类型的现象，当我们使用指针实现接口的，只有指针类型变量才可以实现该接口，当我们使用结构体实现接口的时候，指针类型和结构体类型都会实现该接口。当然并不意味着我们应该一律使用结构体实现接口。在实际工程里面也没那么重要。


**nil和non-nil**
&emsp;通过一个例子理解go语言里面的接口类型并不是任意类型这句话
```bash
➜  语言基础 git:(master) ✗ cat main.go
package main

import "fmt"

type TestStruct struct{}

func NilOrNot(v interface{}) bool {
	return v == nil
}

func main() {
	var s *TestStruct
	fmt.Println(s == nil)
	fmt.Println(NilOrNot(s))
}
➜  语言基础 git:(master) ✗ go run main.go
true
false
```

#### 0x02数据结构
&emsp;将从底层和汇编代码来了解接口的底层数据结构， go语言根据接口类型是否包含一组方法，将接口类型分类成两类:
- 使用`runtime.iface`结构体表示包含方法的接口
- 使用`runtime.eface`结构体表示不包含任何方法的`interface{}`类型
`runtime.eface`结构体在go语言里面定义如下:

```go
type eface struct { // 16个字节
    _type *_type        // 指针，占8个字节
    data unsafe.Pointer // 指针
}
```
&emsp;由于`interface{}`类型不包含任何方法，所以他的结构体也相对比较简单，只包含指向底层数据和类型的两个指针。从上面结构也可以推断出go语言的任意类型都可以转换成为`interface{}`

&emsp;另外一个表示接口的结构体`runtime.iface`这个结构体中有指向原始数据的指针`data`,不过更重要的是`runtime.itab`类型的tab字段。
```go
type iface struct {
    tab *itab
    data unsafe.Pointer
}
```
接下来我们将分析go语言接口中两个类型，`runtime._type`和`runtime.itab`


**类型结构体**
`runtime._type`是go语言类型的运行时表示，下面是运行时包中的结构体。其中包含了很多元信息，例如类型的大小，哈希，对其，以及种类:
```go
type _type struct {
    size uintptr
    ptrdata     uintptr
    hash        uint32
    tflag       tflag
    align       uint8
    fieldAlign  uint8
    kind        uint8
    equal       func(unsafe.Pointer, unsafe.Pointer)bool
    gcdata      *byte
    str         nameOff
    ptrToThis   typeOff
}
```
- `size` 字段存储了类型占用的内存空间，为内存分配提供信息
- `hash` 字段能够帮助我们快速确定类型是否相等
- `equal` 字段用于判断当前类型的对象对象是否相等，该字段是为了减少go二进制文件大小从`typeAlg`结构体里面迁移过来
> 我们只需要对runtime.\_type 结构体中的字段有一个大概的概念，不需要了解所有字段作用和意义。

**itab结构体**
&emsp;`runtime.itab` 结构体是接口类型的核心组成部分，每个`runtime.itab`占据32个字节，可以将它看成接口类型和具体类型的组合，他们分别用`inter`和`_type`来表示
```go
type itab struct { // 32个字节
    inter       *interfacetype
    _type       *_type
    hash        uint32
    _           [4]byte
    fun         [1]uintptr
}
```
&emsp;除了`inter`和`_type`两个用于表示类型的字段之外，上面结构体里面的字段也有自己作用
- `hash`是对`_type.hash`的拷贝。当我们想将`interface`类型转换成具体类型的时候，可以用该字段判断目标类型和具体类型`runtime._type`是否一致。
- `fun` 是一个动态大小的数组，它是一个用于动态派发的的虚函数表，存储了一组函数的指针。虽然该变量被声明成为大小固定的数组，但是在使用的时候会通过原始指针获取其中的数据，所以`fun`里面的保存元素个数是不确定的。
> `hash`在断言里面会被用到，`fun` 会在动态派发的时候会被用到。


#### 0x03 类型转换
&emsp;下面将通过例子深入了解接口类型如何初始化和传递的。同时介绍实现接口使用指针类型和结构体类型的区别，这两种不同的实现方式会导致go语言编译器生成不同的汇编代码，进而影响最终处理过程

**指针类型**
```go
package main
type Duck interface {
	Quack()
}
type Cat struct {
	Name string
}
//go:noinline
func (c *Cat) Quack() {
	println(c.Name + " meow")
}
func main() {
	var c Duck = &Cat{Name: "draven"}
	c.Quack()
}
```
&emsp;使用编译器将上面代码编译成汇编语言/删掉一些对理解无用的语句，`var c Duck = &Cat{Name: "draven"}`相关的代码，这里将汇编语句拆分成三部分理解
- 结构体`Cat`的初始化
- 赋值触发的类型转换过程
- 调用接口的方法`Quack()`
&emsp;先分析下结构体`Cat`的初始化过程:
```asm
    0x0021 00033 (main.go:17)	LEAQ	type."".Cat(SB), AX
	0x0028 00040 (main.go:17)	MOVQ	AX, (SP)
	0x002c 00044 (main.go:17)	PCDATA	$1, $0
	0x002c 00044 (main.go:17)	CALL	runtime.newobject(SB)
	0x0031 00049 (main.go:17)	MOVQ	8(SP), DI
	0x0036 00054 (main.go:17)	MOVQ	DI, ""..autotmp_2+16(SP)
	0x003b 00059 (main.go:17)	MOVQ	$6, 8(DI)
	0x0043 00067 (main.go:17)	PCDATA	$0, $-2
	0x0043 00067 (main.go:17)	CMPL	runtime.writeBarrier(SB), $0
	0x004a 00074 (main.go:17)	JEQ	78
	0x004c 00076 (main.go:17)	JMP	149
	0x004e 00078 (main.go:17)	LEAQ	go.string."draven"(SB), AX
	0x0055 00085 (main.go:17)	MOVQ	AX, (DI)
```
* 获取`Cat`结构体类型指针，并且将它作为参数放到栈上。(0x0021 ~ 0x0028)
* 通过`Call`指定调用`runtime.newobject`函数，这个函数会以`Cat`结构体指针作为参数，分配一段新的内存空间，并且将指向这片内存空间的指针返回到`SP+8`上面 --- 0x002c
* `SP+8`现在存储了一个指向`Cat`结构体指针,为了操作方便，将`SP+8`寄存器里面指针存放到`DI`寄存器里面。 ------------- 0x0031
* 由于cat只包含一个字符串类型的`Name`变量，，所以这里将字符串的长度(6)和字符串的地址`draven(SB)`放到DI上面 （DI+8存放字符串长度，DI存放字符串地址)
&emsp;由于cat结构体的定义中只包含一个字符串，而字符串在go里面总共占据16个字节，所以每个`Cat`结构体的大小都是16个字节，等初始化完成之后就进入了`*Cat`到`Duck`的转换过程了
```asm
	0x005a 00090 (main.go:17)	MOVQ	""..autotmp_2+16(SP), AX
	0x005f 00095 (main.go:17)	MOVQ	AX, ""..autotmp_1+24(SP)
	0x0064 00100 (main.go:17)	LEAQ	go.itab.*"".Cat,"".Duck(SB), CX
	0x006b 00107 (main.go:17)	MOVQ	CX, "".c+32(SP)
	0x0070 00112 (main.go:17)	MOVQ	AX, "".c+40(SP)
	0x0075 00117 (main.go:18)	MOVQ	"".c+32(SP), AX
```
&emsp; 这里临时变量`""..autotmp_2+16(SP)`里面存放了其实是(指向堆Cat那段内存空间的指针)， 0x005a~0x005f 这两行代码是临时创建一个临时变量autotmp1， 接下来
* 将`go.itab.*"".Cat,"".Duck(SB)`的地址存放到CX寄存器里面。 ----- CX = \*itab(go.itab.\*"".Cat,"".Duck) 
* 然后将CX 放到栈`SP+32`的位置上，将AX放到`SP+40`位置上，最后将（SP+32)里面变量放到AX寄存器上，在这个里面CX 里面存放了itab指针，前面一个AX里面存放了指向底层数据的指针，（CX+AX）这两个组合起来就是一个if ace类型

&emsp;最后是调用接口的方法`Quack`
```asm
    0x007c 00124 (main.go:18)	MOVQ	24(AX), AX
	0x0080 00128 (main.go:18)	MOVQ	"".c+40(SP), CX
	0x0085 00133 (main.go:18)	MOVQ	CX, (SP)
	0x0089 00137 (main.go:18)	CALL	AX
```
&emsp;上面代码对应go代码的`c.Quack()`， 将栈CX里面地址放到栈上作为参数，调用AX,(在启用编译器优化后，这个其实调用的0x0051 00081 (main.go:18)	CALL	"".(\*Cat).Quack(SB)), 这个是编译器做的优化，将一些需要动态派发的方法调用直接改为目标方法直接调用，上面汇编就是动态派发的具体过程




**结构体类型**
&emsp;修改下上面代码，使用结构体实现`Duck`接口，并且初始化结构体类型的变量:
```go
package main

type Duck interface {
	Quack()
}

type Cat struct {
	Name string
}

//go:noinline
func (c Cat) Quack() {
	println(c.Name + " meow")
}

func main() {
	var c Duck = Cat{Name: "draven"}
	c.Quack()
}
```
反汇编后如下(启用了编译器优化):
&emsp;还是按照上面三个流程分析下:
- 初始化`Cat`结构体
- 完成`Cat`到`Duck`接口类型的转换
- 调用接口的`Quack`方法
&emsp;先看下汇编代码用于初始化`Cat`结构体的部分
```asm
	0x001d 00029 (main.go:17)	XORPS	X0, X0
	0x0020 00032 (main.go:17)	MOVUPS	X0, ""..autotmp_1+48(SP)
	0x0025 00037 (main.go:17)	LEAQ	go.string."draven"(SB), AX
	0x002c 00044 (main.go:17)	MOVQ	AX, ""..autotmp_1+48(SP)
	0x0031 00049 (main.go:17)	MOVQ	$6, ""..autotmp_1+56(SP)
```
&emsp;这段汇编代码会在栈上初始化`Cat`结构体(栈上占据16个字节)，(和上面一个例子不一样，上面一个例子是在堆上分配了16个字节，将这个内存空间的地址存放在栈上),结构体类型初始化完成后进入类型转换阶段。在转换阶段，编译器会将`go.itab."".Cat,"".Duck`的地址和指向`Cat`结构体的指针作为参数一并传入`runtime.convT2I`函数。
```asm
	0x004c 00076 (main.go:17)	MOVQ	16(SP), AX
	0x0051 00081 (main.go:17)	MOVQ	AX, ""..autotmp_2+24(SP)
	0x0056 00086 (main.go:17)	LEAQ	go.itab."".Cat,"".Duck(SB), CX
	0x005d 00093 (main.go:17)	MOVQ	CX, "".c+32(SP)
	0x0062 00098 (main.go:17)	MOVQ	AX, "".c+40(SP)
```
> 1.15版本并没有调用`convT2I`，而是直创建在栈上构建了一个if ace的变量
&emsp;最后看下调用`Cat`的实现
```asm
0x0067 00103 (main.go:18)	MOVQ	"".c+32(SP), AX
	0x006c 00108 (main.go:18)	TESTB	AL, (AX)
	0x006e 00110 (main.go:18)	MOVQ	24(AX), AX    // AX = AX.fun[0] = Cat.Quack
	0x0072 00114 (main.go:18)	MOVQ	"".c+40(SP), CX //CX = &Cat{Name: ""}
	0x0077 00119 (main.go:18)	MOVQ	CX, (SP)  // SP = CX
	0x007b 00123 (main.go:18)	CALL	AX  // Cat.Quack()
```
&emsp;看下编译器优化后的汇编代码：
```asm
	0x0036 00054 (main.go:18)	LEAQ	go.itab."".Cat,"".Duck(SB), AX
	0x003d 00061 (main.go:18)	TESTB	AL, (AX)
	0x003f 00063 (main.go:17)	MOVQ	16(SP), AX
	0x0044 00068 (main.go:18)	MOVQ	go.itab."".Cat,"".Duck+24(SB), CX
	0x004b 00075 (main.go:18)	MOVQ	AX, (SP)
	0x004f 00079 (main.go:18)	CALL	CX
```
&emsp;主要从`runtime.itab`结构体里面取出`Cat.Quack`方法指针作为`Call`指令，调用时的参数。接口变量的第24个字节就是itab.func数组开始，由于Duck接口只有一个方法，所以itab.func[0]里面存储的指针指向`Quack`方法的指针了。

#### 0x04 类型断言

**非空接口**
&emsp;首选分析接口里面包含方法的情况，`Duck`接口是一个非空接口，分析下`Duck`转换回`Cat`结构体的过程。
```go
     1	package main
     2
     3	type Duck interface {
     4		Quack()
     5	}
     6
     7	type Cat struct {
     8		Name string
     9	}
    10
    11	func (c *Cat) Quack() {}
    12
    13	func main() {
    14		var c Duck = &Cat{Name: "dsda"}
    15		switch c.(type) {
    16		case *Cat:
    17			cat := c.(*Cat)
    18			cat.Quack()
    19		}
    20	}
```
&emsp;我们将编译得到的汇编指令分成两部分，第一部分是变量初始化，第二部分是类型断言，第一部分代码如下
```asm 
	0x001d 00029 (main.go:14)	XORPS	X0, X0
	0x0020 00032 (main.go:14)	MOVUPS	X0, ""..autotmp_4+8(SP)
	0x0025 00037 (main.go:14)	LEAQ	go.string."dsda"(SB), AX
	0x002c 00044 (main.go:14)	MOVQ	AX, ""..autotmp_4+8(SP)
	0x0031 00049 (main.go:14)	MOVQ	$4, ""..autotmp_4+16(SP)
```
&emsp;`0x0025~0x0031`这三个指令初始化了`Duck`变量。`Cat`结构体初始化在`SP+8~SP+24`这个区间内， 下面就开始进入类型转换的过程了o
```asm 
	0x003a 00058 (main.go:15)	CMPL	go.itab.*"".Cat,"".Duck+16(SB), $593696792   ;; switch c.(type)
	0x0044 00068 (main.go:15)	JEQ	80 
	0x0046 00070 (main.go:15)	MOVQ	24(SP), BP
	0x004b 00075 (main.go:15)	ADDQ	$32, SP
	0x004f 00079 (main.go:15)	RET
	0x0050 00080 (main.go:18)	LEAQ	""..autotmp_4+8(SP), AX  ;; cat:=c.(*cat)
	0x0055 00085 (main.go:18)	MOVQ	AX, (SP)
	0x0059 00089 (main.go:18)	PCDATA	$1, $0
	0x0059 00089 (main.go:18)	CALL	"".(*Cat).Quack(SB)
	0x005e 00094 (main.go:18)	NOP
	0x0060 00096 (main.go:15)	JMP	70
	0x0062 00098 (main.go:15)	NOP
```


**空接口**
&emsp;当我们使用空接口类型`interface{}`进行类型断言的时候，如果不关心go语言编译器优化选项的时候，生成的指令不是很多。
&emsp;如果禁用编译器优化，上面断言的时候不是直接从`runtime._type`里面获取，而是从`eface._type`里面获取，汇编指令仍然会使用hash最类型比较


#### 0x05 动态派发
&emsp;动态派发是在运行期间选择具体多态的操作，下面两个例子
```go 
func main(){
    var c Duck = &Cat{Name: "dadsa"}
    c.Quack()
    c.(*Cat).Quack()
}
```
- 上面的例子`Duck`接口类型的身份调用，调用的时候需要经过运行时的动态派发
- 第二次以`*Cat`具体类型身份调用，编译期间就确定调用的函数
&emsp;因为编译器优化影响了我们对原始汇编指令的理解，所以需要不指定`-N`这个参数，编译器会对代码进行重写，与最初的不一样了
- 因为接口类型tab参数没有被使用，所以会优化Cat到Duck的过程
- 因为变量类型的具体类型是确定了，所以会删了从`Duck`接口类型转换到`*Cat`具体类型时可能会发生分之崩溃
&emsp;在具体分析调用`Quack`方法的两种姿势之前，我们先了解

&emsp;动态派发(Dynamic dispatch)是在运行期间选择具体多态操作(方法或者函数)执行的过程
```asm 
0x0021 00033 (main.go:14)	LEAQ	type."".Cat(SB), AX
	0x0028 00040 (main.go:14)	MOVQ	AX, (SP)
	0x002c 00044 (main.go:14)	PCDATA	$1, $0
	0x002c 00044 (main.go:14)	CALL	runtime.newobject(SB)
	0x0031 00049 (main.go:14)	MOVQ	8(SP), DI
	0x0036 00054 (main.go:14)	MOVQ	DI, ""..autotmp_2+32(SP)
	0x003b 00059 (main.go:14)	MOVQ	$7, 8(DI)
	0x0043 00067 (main.go:14)	PCDATA	$0, $-2
	0x0043 00067 (main.go:14)	CMPL	runtime.writeBarrier(SB), $0
	0x004a 00074 (main.go:14)	JEQ	78
	0x004c 00076 (main.go:14)	JMP	191
	0x004e 00078 (main.go:14)	LEAQ	go.string."dasdasa"(SB), AX
	0x0055 00085 (main.go:14)	MOVQ	AX, (DI)
	0x0058 00088 (main.go:14)	JMP	90
	0x005a 00090 (main.go:14)	PCDATA	$0, $-1
	0x005a 00090 (main.go:14)	MOVQ	""..autotmp_2+32(SP), AX
	0x005f 00095 (main.go:14)	MOVQ	AX, ""..autotmp_1+40(SP)
	0x0064 00100 (main.go:14)	LEAQ	go.itab.*"".Cat,"".Duck(SB), CX
	0x006b 00107 (main.go:14)	MOVQ	CX, "".c+48(SP)
	0x0070 00112 (main.go:14)	MOVQ	AX, "".c+56(SP)
```
我们先看下Cat如何初始化的，，初始化完成后栈上有哪些数据: 首先初始化了一个`Cat`的指针，再将`Cat`和`tab`打包成一个`runtime.iface`结构体。
栈上数据如下
- `SP` 是`Cat`类型，它也是运行`runtime.newobject`方法的参数
- `SP+8` 是`runtime.newobject`方法返回值。即指向堆上的`Cat`结构体的指针。
- `SP+32, SP+40`是对`SP+8`的拷贝，这两个指针都会指向`Cat`结构体的指针
- `SP+48~SP+64`是接口变量`runtime.iface`结构体，其中包含了`tab`和`*Cat`指针

&emsp;初始化完成后进入动态派发的过程`c.Quack`语句展开汇编指令如下:
```asm 
	0x0075 00117 (main.go:15)	MOVQ	"".c+48(SP), AX
	0x007a 00122 (main.go:15)	TESTB	AL, (AX)
	0x007c 00124 (main.go:15)	MOVQ	24(AX), AX
	0x0080 00128 (main.go:15)	MOVQ	"".c+56(SP), CX
	0x0085 00133 (main.go:15)	MOVQ	CX, (SP)
	0x0089 00137 (main.go:15)	PCDATA	$1, $1
	0x0089 00137 (main.go:15)	CALL	AX
```
&emsp;上面的汇编指令主要指定下面三个步骤：
- 从接口变量中获取保存`Cat.Quack`方法指针的 `tab.func[0]`
- 接口变量在`runtime.iface`中数据会被拷贝到栈顶（func[0]的参数)
- 方法指针被拷贝到寄存器，并且通过汇编指定`Call`来调用


&emsp;另外一个调用`Quack`方法语句`c.(*Cat).Quack()`方法生成的汇编指令如下:
```asm 
	0x008b 00139 (main.go:16)	MOVQ	"".c+48(SP), AX
	0x0090 00144 (main.go:16)	MOVQ	"".c+56(SP), CX
	0x0095 00149 (main.go:16)	LEAQ	go.itab.*"".Cat,"".Duck(SB), DX
	0x009c 00156 (main.go:16)	NOP
	0x00a0 00160 (main.go:16)	CMPQ	AX, DX
	0x00a3 00163 (main.go:16)	JEQ	167
	0x00a5 00165 (main.go:16)	JMP	205
	0x00a7 00167 (main.go:16)	MOVQ	CX, ""..autotmp_3+24(SP)
	0x00ac 00172 (main.go:16)	MOVQ	CX, (SP)
	0x00b0 00176 (main.go:16)	PCDATA	$1, $0
	0x00b0 00176 (main.go:16)	CALL	"".(*Cat).Quack(SB)

```
&emsp;代码大部分都是在做类型转换，只有最后两行才是代码调用，第一次调用的函数指针在编译期间就确定了，运行时候不需要动态查找了。

> 两次调用的对应的汇编指令差异就是动态派发带来的额外开销，这些额外的开销在低延迟，高吞吐量需求的服务中是不可以被忽略的
结论直接调用要比动态派发性能好大约80-90%


