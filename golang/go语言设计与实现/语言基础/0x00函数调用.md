**函数调用**

&emsp;在go里面函数调用参数和返回值的传递是通过值传递的
- 普通类型(基本类型/结构体) - 完全copy
- 指针， 拷贝指针的值(会有两个指针，同时指向同一个原始内存区域)


#### 0x00 调用惯例
&emsp;不同语言之间函数调用语法基本类似:`somefunction(arg1, arg2)`, 但是不同语言调用惯例不一样， 调用惯例：调用方和被调用方关于参数传递和返回值传递的约定;
&emsp;c语言通过寄存器传惨，go语言通过栈传参(但是这个在1.17以后做了变动，也改为通过寄存器传参数了)
&emsp;下面通过例子分析下go语言调用惯例:
```go
package main
func myFunction(a,b int)(int, int) {
    return a + b, a - b
}
func main(){
    myFunction(66, 77)
}
```
> 通过`go1.15.4 tool compile -S -N -l main.go` 编译反汇编
```asm
"".main STEXT size=71 args=0x0 locals=0x28
	0x0000 00000 (main.go:6)	TEXT	"".main(SB), ABIInternal, $40-0
	0x0000 00000 (main.go:6)	MOVQ	(TLS), CX
	0x0009 00009 (main.go:6)	CMPQ	SP, 16(CX)
	0x000d 00013 (main.go:6)	PCDATA	$0, $-2
	0x000d 00013 (main.go:6)	JLS	64
	0x000f 00015 (main.go:6)	PCDATA	$0, $-1
	0x000f 00015 (main.go:6)	SUBQ	$40, SP             // 分配40字节栈空间
	0x0013 00019 (main.go:6)	MOVQ	BP, 32(SP)          // 保存基地址存储到栈上
	0x0018 00024 (main.go:6)	LEAQ	32(SP), BP          
	0x001d 00029 (main.go:6)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (main.go:6)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x001d 00029 (main.go:7)	MOVQ	$66, (SP)           // 将第一个参数66存储到栈上
	0x0025 00037 (main.go:7)	MOVQ	$77, 8(SP)          // 将第二个参数77 存储到栈上
	0x002e 00046 (main.go:7)	PCDATA	$1, $0
	0x002e 00046 (main.go:7)	CALL	"".myFunction(SB)
	0x0033 00051 (main.go:8)	MOVQ	32(SP), BP
	0x0038 00056 (main.go:8)	ADDQ	$40, SP
	0x003c 00060 (main.go:8)	RET
	0x003d 00061 (main.go:8)	NOP
	0x003d 00061 (main.go:6)	PCDATA	$1, $-1
	0x003d 00061 (main.go:6)	PCDATA	$0, $-2
	0x003d 00061 (main.go:6)	NOP
	0x0040 00064 (main.go:6)	CALL	runtime.morestack_noctxt(SB)
	0x0045 00069 (main.go:6)	PCDATA	$0, $-1
	0x0045 00069 (main.go:6)	JMP	0
```
&emsp;main函数通过`SUBQ $40, SP`指令在栈上开辟了40个字节大小空间
|空间|大小|作用|
|----|----|----|
|SP+32 ~ BP| 8 字节 | main函数的栈基址指针|
|SP+16 ~ SP+32| 16 个字节 | 函数`myFunction`两个返回值|
|SP~SP+16|16字节|函数`myFunction`两个参数|

> `myFunction`入参的压栈顺序和C语言一样，都是从右到左，即第一个参数66在栈定`SP+8`， 第二个参数在存储在`SP+8 ~ SP+16`空间里面。
&emsp;当准备好函数如惨函数之后调用汇编指令`CALL "".myFunction(SB)` 这个指令先将main的返回地址存入栈里面，然后改变当前的栈指针SP 并执行`myFunction`汇编指令。

```asm
"".myFunction STEXT nosplit size=49 args=0x20 locals=0x0
	0x0000 00000 (main.go:3)	MOVQ	$0, "".~r2+24(SP)  // 初始化第一个返回值
	0x0009 00009 (main.go:3)	MOVQ	$0, "".~r3+32(SP)  // 初始化第二个返回值
	0x0012 00018 (main.go:4)	MOVQ	"".a+8(SP), AX      // 将第一个参数放入寄存器AX 里面
	0x0017 00023 (main.go:4)	ADDQ	"".b+16(SP), AX     // 将第二个参数 + AX 放入AX里面
	0x001c 00028 (main.go:4)	MOVQ	AX, "".~r2+24(SP)   // (24)SP = AX = 143
	0x0021 00033 (main.go:4)	MOVQ	"".a+8(SP), AX      // AX = 66
	0x0026 00038 (main.go:4)	SUBQ	"".b+16(SP), AX     // AX = AX - 77 = -11
	0x002b 00043 (main.go:4)	MOVQ	AX, "".~r3+32(SP)   // (32)SP = AX = -11
	0x0030 00048 (main.go:4)	RET
```
&emsp;从上面的汇编代码看出，当前函数在执行时候会现将`main`函数预留的两个返回地址初始化为0，然后根据栈的相对位置获取参数并执行加减，在`myFunction``返回后通过以下指令恢复栈指针并销毁已经失去作用的40个字节栈内存
```asm
	0x0033 00051 (main.go:8)	MOVQ	32(SP), BP
	0x0038 00056 (main.go:8)	ADDQ	$40, SP
```

&emsp;c语言和go语言在设计上选择不同的实现，C语言使用寄存器和栈传参，使用eax寄存器传递返回值，而go语言使用栈传惨和返回值，对比下他们优缺点L
- C 语言方式减少函数调用的额外开销，但是增加了实现复杂度
- - cpu访问栈的开销要比访问寄存器高几十倍
- - 需要单独处理函数参数过多的情况
- go语言的方式降低实现复杂度，并支持多返回值，但是牺牲了函数调用性能
- - 不需要考虑超过寄存器数量的参数应该如何传递参数
- - 不需要考虑不同架构上的寄存器差异
- - 函数的入参和出参的内存空间需要额外分配


#### 0x01 参数传递
&emsp;除了调用惯例不一样之外，go语言在传递参数时候传值还是传引用也是不一样的。传值和传引用的区别
- 传值: 函数调用时候会对参数进行拷贝，被调用方和调用方会持有两份不相关的数据。
- 传引用: 函数调用收获会传递参数的指针，被调用方和调用方持有两份相通的数据，任何一方做修改都会影响另外一方。
> 不同的语言会选择不同的方式传参数，go语言选择传值方式的方式，无论是基本类型，


**整型和数组**
&emsp;我们先分析下go如何传递基本类型和数组的，如下面所示函数`myFunction`
```go
package main

import "fmt"

func myFunction(i int, arr [2]int) {
	fmt.Printf("in my_function          - i = (%d %p), arr = (%v, %p)\n", i, &i, arr, &arr)
}

func main() {
	i := 30
	arr := [2]int{66, 77}
	fmt.Printf("before call my_function - i = (%d %p), arr = (%v, %p)\n", i, &i, arr, &arr)
	myFunction(i, arr)
	fmt.Printf("after call my_function  - i = (%d %p), arr = (%v, %p)\n", i, &i, arr, &arr)

}
```
> 运行结果如下
```bash
$ go run main.go
before call my_function - i = (30 0xc00001a0b8), arr = ([66 77], 0xc00001a0c0)
in my_function          - i = (30 0xc00001a0e0), arr = ([66 77], 0xc00001a0f0)
after call my_function  - i = (30 0xc00001a0b8), arr = ([66 77], 0xc00001a0c0)
```
> 当我们通过命令航来运行这段代码的时候会发现`main`函数和被调用者`myFunction`中的参数的地址是完全不同的。不过从main函数的角度来看，在调用`myFunction`前后都没有差别。但是如果在`myFunction`函数的内部对参数修改，会如何影响`main`函数中变量？
 ```go
 before call my_function - i = (30 0xc0000b2008), arr = ([66 77], 0xc0000b2010)
in my_function          - i = (29 0xc0000b2030), arr = ([66 29], 0xc0000b2040)
after call my_function  - i = (30 0xc0000b2008), arr = ([66 77], 0xc0000b2010)
 ```
> 运行如下:
```bash
before call my_function - i = (30 0xc0000b2008), arr = ([66 77], 0xc0000b2010)
in my_function          - i = (29 0xc0000b2030), arr = ([66 29], 0xc0000b2040)
after call my_function  - i = (30 0xc0000b2008), arr = ([66 77], 0xc0000b2010)
```
&emsp;从上面例子可以看出在`myFunction`中对参数修改也仅仅影响当前的函数，并没有影响调用方`main`函数，所以*go语言的整型和数组都是值传递* 也就是在调用函数的时候会进行值拷贝，当数组特别大的时候会有性能问题.

**结构体和指针**
&emsp;继续分析下go常见的两种类型-结构体和指针
```go
package main

import "fmt"

type MyStruct struct {
	i int
}

func myFunction(a MyStruct, b *MyStruct) {
	a.i = 31
	b.i = 41
	fmt.Printf("in my_function          - i = (%d %p), arr = (%v, %p)\n", a, &a, b, &b)
}

func main() {
	a := MyStruct{i: 30}
	b := MyStruct{i: 40}
	fmt.Printf("before call my_function - i = (%d %p), arr = (%v, %p)\n", a, &a, b, &b)
	myFunction(a, &b)
	fmt.Printf("after call my_function  - i = (%d %p), arr = (%v, %p)\n", a, &a, b, &b)

}
```
运行结果:
```bash
before call my_function - i = ({30} 0xc00012a008), arr = ({40}, 0xc00012a010)
in my_function          - i = ({31} 0xc00012a018), arr = (&{41}, 0xc000124020)
after call my_function  - i = ({30} 0xc00012a008), arr = ({41}, 0xc00012a010)
```
&emsp;从上面我们可以得出如下结论
- 在传递结构体的时候会拷贝结构体里面全部内容
- 传递结构体指针的时候， 会拷贝结构体的指针
> 修改结构体指针是改变指针指向的结构体， `b.i` 可以理解成`(\*b).i`，也就是先获取`b`背后的指针，在修改结构体的变量，下面我们在分析下go语言在结构体里面的布局

```go
package main

import (
	"fmt"
	"unsafe"
)

type MyStruct struct {
	i int
	j int
}

func myFunction(ms *MyStruct) {
	ptr := unsafe.Pointer(ms)
	for i := 0; i < 2; i++ {
		c := (*int)(unsafe.Pointer((uintptr(ptr) + uintptr(8*i))))
		*c += i + 1
		fmt.Printf("[%p]  %d\n", c, *c)
	}
}

func main() {
	a := &MyStruct{i: 40, j: 50}
	myFunction((a))
	fmt.Printf("[%p]  %d\n", a, *a)
}
```
执行结果如下:
```bash
➜  语言基础 git:(master) ✗ go run main.go
[0xc00001a0c0]  41
[0xc00001a0c8]  52
[0xc00001a0c0]  {41 52}
```
&emsp;在上面这段代码里面，通过指针修改结构体里面成员变量,结构体在内存里面是一段连续的内存空间，指向结构体的指针也是指向这个结构体的首地址。 将`MyStruct`指针修改为`int`类型的指针，那么访问新指针就会返回整型变量`i`的值，在将指针移动8个字节后，就能获取下一个变量`j`
&emsp; 将上面代码简化，并且反汇编
```go
type MyStruct struct {
	i int
	j int
}

func myFunction(ms *MyStruct) *MyStruct {
	return ms
}

```
> `➜  语言基础 git:(master) ✗ go1.15.4 tool compile -S -l -N main.go`
```asm
	0x0000 00000 (main.go:12)	TEXT	"".myFunction(SB), NOSPLIT|ABIInternal, $0-16
	0x0000 00000 (main.go:12)	FUNCDATA	$0, gclocals·524d71b8d4b4126db12e7a6de3370d94(SB)
	0x0000 00000 (main.go:12)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0000 00000 (main.go:12)	MOVQ	$0, "".~r1+16(SP)           // 初始化返回值
	0x0009 00009 (main.go:13)	MOVQ	"".ms+8(SP), AX             // 复制引用
	0x000e 00014 (main.go:13)	MOVQ	AX, "".~r1+16(SP)           // 返回引用值
```
> 在下面这端汇编里面，当参数是指针的时候，也会用`movq "".ms+8(SP) , AX` 指令复制引用，然后将复制后的只恨作为返回值传递回调用方。
&emsp;在go里面，将指针作为参数传入某个函数的时候，函数内部也会复制指针，也就是会有两个同时指向原有内存空间的的指针。所以go语言里面传指针也是传值。



#### 0x02 小结

