`Dijkstra`比较保守，它是将有可能变成存活的对象都标记为灰色-来满足强三色一致性，实现也简单（但是会有冗余问题，冗余的对象需要等待下一轮才会被收集)
另外一点: 栈上的对象会被认为是根对象，为了保证内存一致性，`Dijkstra`需要为栈上的对象增加写屏障或者在标记完成重新对栈上的对象进行扫描。但是两种方法个有缺点前面一种：增加写指针的开销，后面一种重新扫描需要STW。

`Yuasa`核心思想是开启屏障的时候保证了堆上的对象都是可达的(也被成为快照垃圾回收器), 核心思想是在删除老对象的引用的时候，会吧老对象标记成灰色，满足第二条来保证弱三色不变性(这样老对象的下游一定会被扫描到，因为老对象是灰色的了), 缺点：拦截写操作，产生冗余的扫描，导致波面退后

#### 设计原理
&emsp;在下面的图片里面，用户程序(mutator)会通过内存分配器(allocator)在堆上申请内存，在垃圾回收负责在堆上回收内存。内存分配器和垃圾回收共同管理着程序里面的堆内存空间，我们将在这个章节里面介绍垃圾回收用到的一些理论知识。

**标记清除**
&emsp;标记清除(Mark-Sweep)算法是最常见的垃圾回收算法，标记清除收集器是跟踪式的垃圾回收器，其执行过程可以分为标记(Mark)和清除(Sweep)两个阶段
- 标记阶段 - 从根对象出发，查找并标记堆里面所有存活的对象
- 清除阶段 - 遍历堆里面全部的对象，回收那些没有被标记的垃圾对象，并且将其回收的内存加入到空闲链表里面
&emsp;这个是比较简单的标记清除，在标记清除阶段用户是不能执行任何操作的，因此需要更复杂的机制STW的问题。



**三色抽象**
&emsp;为了解决原始标记清除算法带来长时间的STW，多数现代的追踪式垃圾回收器都会实现三色标记算法的变种，以缩短STW的时间。三色标记算法将程序里面的对象分为白色，黑色，灰色三类:
- 白色对象 - 潜在的垃圾，其内存可能会被垃圾回收清除
- 黑色对象 - 活跃的对象，包括不存在任何引用外部指针的对象和根对象可达的对象
- 灰色对象 - 活跃的对象，因为存在只想白色的外部指针，垃圾回收器会扫描这些对象的子对象。

&emsp;垃圾收集器在开始工作的时候，程序里面不存在任何的黑色对象，垃圾收集的根对象会被标记为灰色，垃圾回收器只会从灰色对象集合中取出对象开始扫描，当灰色对象中不存在任何对象时候，标记工作就结束

&emsp;三色标记垃圾回收收集器工作原理很简单，我们可以将他归纳成以下几个:
- 从灰色对象的集合里面选择一个灰色对象，并且将它标记成黑色
- 将黑色的对象指向的所有的对象都标记成灰色的，以保证该对象和被该对象引用的对象都不会被回收
- 重复上面的两个步骤，直到对象图里面不存在任何灰色对象

&emsp;存在并发问题，在垃圾回收器工作的时候，用户仍然可以继续工作（但是如果处理不当可能会导致悬浮指针的问题)

**屏障技术**
&emsp;内存屏障技术其实是一种屏障指令，它可以让CPU和编译器执行内存相关操作的时候遵循某种特定的约束，目前多数现代处理器都会乱序的执行指令以最大化性能。在内存屏障执行前的操作一定会先与内存屏障后执行的操作。 这属于一种契约，语言和语言用户之间的契约。保证代码描述里面对内存的操作顺序不会在编译期间被编译器调整，也不会在运行的时候被CPU的乱序执行所打破.

&emsp;想要在并发或者增量的标记算法里面保证准确性，需要达成以下两种三色不变性(Tri-color invariant)的一种:
- 强三色不变性: 黑色的对象不会指向白色的对象，只会指向灰色的对象或者黑色对象
- 弱三色不变性: 黑色对象指向的白色对象必须包含一条从灰色对象经过多个白色对象的可达路径

&emsp;垃圾回收器的屏障技术更像一个钩子方法，它是用户程序在读取对象，创建新对象以及更像对象指针时候需要执行的一段代码，根据操作类型可以分为读屏障(Read Barrier)和写屏障(Write Barrier)两种，因为写屏障需要在读操作里面增加大量的代码片段，对用户的程序影响很大，所以编程语言一般会采用读屏障来保证三色不变性。 在go语言里面才用了`Dijkstra`的插入写屏障和`Yuasa`提出的删除写屏障，下面分析下他们如何保证三色不变性的。

&emsp;垃圾回收器的正确性应该表现为: 不应该出现对象的丢失, 也不应错误的回收不需要回收的对象。 作为内存屏障的一种，写屏障是一个在并发垃圾回收器里面才会出现的.
&esmp;经证明当出现下面两种情况同时被满足，那么会破坏垃圾回收器的正确性质:
- 条件1: 赋值器修改对象图，导致某一个黑色的对象引用了白色对象(-----这个其实本身没啥，但是加上下面一个条件，但是如果没有灰色的对象到到这个白色，那么有可能有问题了，这个白色对象理论上不应该被删除，却没有机会被标记为灰色/黑色，导致它被删除了)
- 条件2: 从灰色对象出发,到达白色对象的，未被访问过的路径被删除了。

&emsp;可以证明只要避免其中任何一个条件，就不会有问题:
- 如果避免条件1，所有的白色对象均被灰色对象引用，这样不会存在遗漏
- 如果避免了条件2， 即使白色对象的指针被写入了黑色的对象里面，但是从灰色对象总能找到一条没有被访问过的路径到达这个白色对象，最终白色对象被标记为灰色-黑色，这样就没问题了)

&emsp;当条件1和条件2都不满足，----- 强三色不变性， 但是如果满足条件1(但是不满足条件2)----弱三色不变性


**赋值器颜色**
&emsp;如果考虑并发的用户态代码，回收器不允许同时停止所有的赋值器(因为需要并发),这就涉及了存在多个不同状态的赋值器。为了加强这个概念的理解，需要转换一个角度，把回收器视为对象，把赋值器视为影响对象的某个操作，从而引入赋值器的颜色。
- 黑色赋值器: 已经由回收器扫描过了，不会再次对它进行扫描了。
- 灰色赋值器: 尚未被回收器扫描过，或者说已经被回收器扫描了，但是仍然需要被回收器进一步的扫描。
&emsp;赋值器的颜色对回收周期的结束是有影响的：如果某种并发回收器允许灰色赋值器的存在，则必须在回收之前重新扫描对象图。如果重新扫描过程里面发现了新增的灰色或者白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然是有可能插入新的非黑色的引用，如此往复，直到重新扫描里面没有发现新的白色或者灰色的对象。于是在允许灰色赋值器存在的算法，最坏的情况下，回收器只能将所有赋值器线程停止才能完成其对象图的扫描，也就是STW。


**新分配对象的颜色**
&emsp;新分配过程会导致赋值器持有新分配对象的引用。可想而知我们需要为新产生的对象分配适当的颜色，那么新分配的对象的颜色会产生不同的影响：
- 如果新分配的对象为黑色或者灰色，那么赋值器直接视其为无需回收的对象，写入堆里面
- 如果新分配的对象为白色，则可以避免无意义的新对象保留到下一个回收周期里面

&emsp;如果进一步的考虑，能够发现，由于黑色赋值器由于已经被回收器扫描过了，不再会对其进行任何扫描，一旦其分配的新的白色对象，则意味会会导致错误的回收。因此黑色赋值器不能产生白色的对象，除非赋值器能够保证新分配的白色对象的引用能够被写入到灰色的波面中，但是实现起来不是那么简单，为了简化实现的复杂度，零新分配的对象为褐色通常是安全的。


**赋值器屏障技术**
&emsp;在讨论垃圾回收器的写屏障技术，一般值赋值器的写屏障，即赋值器屏障。赋值器屏障作为一种同步的机制，使得赋值器在进行指针写操作的时候，能够“通知”回收器，从而不会破坏弱三色不变性:
&emsp;屏障上需要依赖多种操作来应对指针的插入和删除操作 ：
- 扩大波面: 将白色对象变成灰色
- 推进波面: 扫描对象并将其着色为黑色
- 后退波面: 将黑色对象退回灰色

&emsp;根据灰色赋值器和黑色赋值器的不同，分别会有不同类型的赋值器屏障。针对两种不同类型的赋值器来介绍两个和go相关的赋值器屏障: 灰色赋值器屏障`Dijkstra`插入屏障，和黑色赋值器屏障`Yuasa`删除屏障


**灰色赋值器Dijkstra插入屏障**
&emsp;插入屏障技术又成为增量更新屏障，其核心思想是把赋值器对已经存活的对象集合的插入行为通知给回收器，进而产生可能需要额外(重新)扫描的对象。如果一个都对象的引用被插入到已经被标记为黑色的对象中，这类屏障会保守的将它当作非白色的存活对象，以满足强三色不变性
&emsp;`Dijkstra`插入屏障作为诸多插入屏障的一种，对于插入到黑色对象里面的白色指针，无论其在未来是否会被赋值器删除，该屏障都会为其标记为可达(无论是黑色还是灰色，都避免条件1的出现。)
```go
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer){
    shade(prt)
    *slot = ptr
}
```
&emsp;`shade(ptr)`会将尚未变成灰色或者黑色指针ptr标记为灰色。通过保守的假设`*slot`有可能会变成黑色，并且确保`ptr`不会在将赋值为`*slot`前变成白色，进而确保了强三色的不变形。
&emsp;这种三色不变性的优势:
- 性能优势：它不需要对指针做任何操作(指针的读要比写多出几个数量级)
- 前进保障: 与steele 不同，对象可以从白色到灰色单调的转换为黑色，因此工作总量受到堆大小的限制

&emsp;同样也有缺点:
- 这是一种保守的插入屏障，在一次回收过程里面可能差生一部分被染黑的垃圾对象，只有在以下次清扫的时候才会被删除
- 在标记阶段，每次指针赋值操作都需要引入写屏障，这个无疑会增加性能的开销，为了避免性能的问题，可以选择关闭栈上的指针写操作的`Dijkstra`写屏障。当发生栈上写操作的时候，将它恒标记为灰色的。但是这样操作产生了灰色赋值器，需要标记终止阶段STW对这些栈进行重新扫描。



**Yuasa删除屏障**
&emsp;黑色赋值器的Yuasa删除屏障又称基于快照的屏障。其思想是当赋值器从灰色或者白色中删除对象的时候，通过写屏障将这个操作告诉并发执行的回收器。这个过程很像是操作对象图之前进行一次快照。
&emsp;如果一个指针位于波面之前，则删除屏障会保守的将目标对象标记为非白色的存活对象，进而避免条件2来满足弱三色不变性。具体来说Yuasa删除屏障在回收过程里面，对于被赋值器删除最后一个指向这个对象导致该对象不可达情况，仍然将其对象进行着色：
```go 
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer){
    shade(*slot)
    *slot = ptr
}
```
&emsp;为了防止丢失从灰色对象到白色对象的路径，应该假设`*slot`可能会变成黑色，为了确保ptr不会在被赋值到`*slot`前变为白色，shade(\*slot) 会现将`*slot`标记为灰色，进而该写操作总是能创建一条从灰色到灰色，或者从灰色到白色路径，避免了条件2
&emsp;Yuasa删除屏障优势在于不需要标记结束段之后重新扫描，结束的时候能够准备的回收所需要回收的白色对象，缺陷是Yuasa删除屏障会拦截写操作，进而导致波面后退，产生冗余的扫描。


**混合写屏障**
&emsp;在诸多屏障技术里面，go使用了`Dijkstra`与`Yuasa`屏障的结合，即混合写屏障(`Hybird write barrier`技术)， go在1.8为了简化gc流程，同时减少标记终止阶段的重新扫描成本，将`Dijkstra`插入屏障和`Yuasa`删除屏障进行混合，形成了混合写屏障




#### 混合屏障基本思想
&emsp;该屏障提出的时候基本思想:对正在被覆盖的对象进行着色，如果当前栈未扫描完成，则同样对指针进行着色。
```go 
func HybirdWritePointerSImple(slot *unsafe.Pointer, ptr unsafe.Pointer){
    shade(*slot)
    shade(ptr)
    *slot = ptr
}
```
&emsp;在go1.8之前为了减少写屏障的成本，go选择没有启动栈上的写操作的写屏障，赋值器总是可以通过将一个单一的指针移动到某个已经被扫描的后的栈，从而导致某个白色对象被标记为灰色，进而隐藏到黑色之下，进而需要对栈进行重新扫描，甚至导致栈总是灰色的，因此需要STW。

&emsp;混合写屏障为了消除栈的重新扫描过程，因为一旦栈被扫描为黑色，则它会一直保持为黑色的状态，并且要求将对象分配为喝死额



**批量写屏障机制**
&emsp;在go1.8里面实现里面，需要对引用的双发进行着色，自然结合了两种屏障的优势，但是着色的成本就是双倍的了，而且编译器插入代码的成本也增加了，随之带来的问题就是二进制文件大小也进一步增加，为了针对写屏障的性能优化，go1.10之后引入了批量写屏障缓存机制，将需要着色的指针统一写入到一个缓存里面，每当缓存满了的时候，对里面所有的ptr指针进行着色。



**优化**
&emsp;优化:
- 增量垃圾回收 - 增量的标记和清除垃圾，降低应用程序时间暂停时长 
- 并发的垃圾回收 - 利用多核的计算资源，在用户程序执行时并发的执行标记和清除操作



#### 演进过程
&emsp;1.5里面引入了并发的垃圾回收，并发的垃圾回收需要在合适的时间点触发垃圾回收循环，go语言并发的垃圾回收器会在扫描对象之前做一些暂停应用程序，做一些准备工作(包括启动后台标记的垃圾回收器，以及开启写屏障)，如果后台执行的垃圾回收器执行不够快，或者申请内存的速度大大超过了预期，运行的时候会让申请内存的应用程序辅助完成垃圾收集扫描阶段。在标记和标记终止阶段结束之后就会进入异步的清除工作，将不用的内存回收掉。 
&emsp;在1.5实现的并发收集策略由专门的goroutine负责在处理器之间同步和协调垃圾回收器的状态。当其他的goroutine需要触发垃圾回收器的时候，他们需要将该信息同步给负责修改状态的主的goroutine。但是这个通知是有一定延迟的，并且这个延迟的窗口是不可控的，用户会在这个延迟窗口之间继续分配内存 ----------- (个人注释：也许会在这个时候触发STW，但是影响效率)

&emsp;在v1.6里面实现了去中心化的垃圾收集协调机制，将垃圾收集器变成一个显示的状态机，任意的goroutine都可以调用方法触发状态的迁移，常见的迁移状态有如下几种:
- runtime.gcStart:  从`_GCoff`转换到`_GCmark`，这个时候进入并发标记阶段，并且打开写屏障
- runtime.gcMarkDOne: 如果所有的可达对象都扫描完成了，调用`runtime.gcMarkTermination`
- runtime.gcMarkTermination:  状态从`_GCmark`转换为`_GCTermination`阶段，进入标记终止阶段，并且在完成后进入`_GCOff`阶段。
&emsp;上面三个方法的引入主要解决的是去中心化的问题

**回收堆目标**
&emsp;STW的垃圾回收器虽然需要短暂的暂停，但是它能有效的控制堆内存的大小，go语言运行时候默认配置会在堆内存到达上一次堆内存的2倍的时候，触发一次新的一轮GC，这个行为可以通过环境变量来控制，
&emsp;因为并发程序收集器会和应用程序一起执行，所以它没有办法准确有效的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能有效的保证内存的可控，并发收集器需要尽可能的保证收集结束的时候堆内存和用户配置的GOGC 一致

&emsp;go语言在1.5里面引入了并发收集器的同时使用垃圾回收算法`Pacing`算法计算触发的垃圾收集的最佳时间，确保每次触发既不会浪费计算资源，也不会超出预期的堆大小。

**混合写屏障**
&emsp;在1.7之前，运行时才用了`Dijkstra`插入写屏障保证强三色不变性，但是运行时没有在所有的垃圾收集器根对象上面开启写屏障(因为可能有成百上千个goroutine，而垃圾回收收集的根对象一般包含全局变量和栈对象)。如果需要在几百个goroutine上面都开启写屏障，会带来巨大的开销，所以go团队在实现选择上标记阶段完成时暂停程序，将所有的栈上面对对象为灰色的重新扫描一次，(在活跃goroutine非常多的环境里面这个大概占用10-100ms)时间。

&emsp;在1.8 引入了`Dijkstra`和`Yuasa`混合写屏障，混合写屏障会将被覆盖的对象标记为灰色， 并且在当前栈没有扫描时将新对象也标记为灰色
```go 
func writePointer(slot *unsafe.Pointer, ptr unsafe.Pointer){
    shade(*slot)    // 删除写屏障
        if current stack is gray {
            shade(ptr)  // 插入写屏障
        }
    *slot = ptr
}
```
&emsp;为了移除所有重新扫描的过程，除了引入了混合写屏障之外，在垃圾收集阶段，还将所有创建的新的对象都标记为黑色，防止新分配的栈内存和堆内存的对象被错误的回收，因为栈在标记阶段最终都会成为黑色。


#### 实现原理
&emsp;go语言的垃圾回收可以分成`清除终止`,`标记`,`标记终止`,`清除`四个不同的阶段。

**清理终止阶段**
- 暂停程序， 所有的处理器都会在这个时候进入安全点
- 如果当前的垃圾回收是强制触发的，我们还需要处理没有被清理的内存管理单元

**标记阶段**
- 将状态切换到`_GCMark`，开启写屏障，用户切换协助(Mutator Assists)并且将跟对象入队列
- 恢复执行程序，标记进程和用于协助的用户程序会并发的开始标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记为灰色，而所有新创建的对象会直接被标记为黑色
- 开始扫描根对象，包括所有的goroutine的栈，全局对象，以及不在堆里面的数据结构，扫描goroutine栈期间会暂时的暂停当前处理器
- 依次处理灰色队列里面的对象，将对象标记成黑色并且将他们的指向标记为灰色
- 使用分布式的终止算法检查剩余工作，发现标记阶段完成后进入标记终止阶段

**标记终止阶段**
- 暂停程序，将状态切换到`_GCMarkTermination`开始关闭辅助标记的用户程序
- 清理处理器的线程缓存

**清理阶段**
- 将状态切换到`_GCOff`，开始清理阶段，初始化清理状态，关闭写屏障，
- 恢复用户程序，所有新创建的对象会被标记为白色。
- 后台并发清理所有的内存管理单元，当goroutine申请新的内存管理单元的时候就会触发清理

&emsp;虽然运行时只会使用`_GCoff`,`_GCmark`, `_GCMarkTermination`三个状态表示垃圾回收全部阶段，但是实现却是非常的复杂的



#### 全局变量
&emsp;在垃圾回收里面有一些比较重要的全局变量，在分析之前先逐个介绍这些变量，这些变量会在垃圾收集阶段反复出现，
- runtime.gcphase：  表示垃圾回收当前所处于的阶段， 可能处于`_GCoff, _GCmark 和 _GCmarktermination goroutine` 在读取或者修改阶段这个变量需要保证它的原子性
- runtime.gcBlackenEnabled  是一个布尔值，当垃圾收集器处于标记阶段，这个值会被设置为1，在这里赋值垃圾收集的用户程序和后台标记的任务可以将对象标记为黑色
- runtime.gcController  gccontroller实现了垃圾收集的调步算法，他能够决定触发并行的垃圾回收时间和待处理的工作。
- runtime.gcpercent 是触发垃圾收集的内存增长百分比，默认情况下为100%时就触发GC，并行的垃圾收集器会在到达该目标之前完成收集
- runtime.writeBarrier 是一个包含写屏障状态的结构体，其中enable字段用来控制写屏障的开启和关闭
- runtime.worldsema 是全局的信号量，获取该信号量的线程有权利暂停当前的应用程序
- runtime.work 这个结构体里面包含了大量的和垃圾回收相关的字段。



#### 触发时机
&emsp;运行时通过如下的`runtime.gcTrigger.test`方法来决定是否触发垃圾回收，当满足触发垃圾收集的基本条件的时候-允许垃圾收集，程序没有崩溃并且没有处于垃圾收集循环的时候， 该方法会根据三种不同的方式触发不同的检查
- gcTriggerHeap:   对分配内存到达控制器计算的触发的堆大小
- gcTriggerTime: 如果一段时间没有触发了，那么就会触发一轮新的GC，这个默认由forcegcperiod 来控制，默认是2分钟
- gcTrieerCycle: // 如果当前没有开启垃圾回收，那么则开始新的一轮触发

&emsp;用于开启垃圾收集的方法`runtime.gcStart`会接受到一个`runtime.gcTrigger`类型的谓词，所有出现`runtime.gcTrigger`结构体的为止都是触发垃圾收集的代码
- runtime.sysmon 和 runtime.forcegchelper 后台运行定时检查和垃圾回收
- runtime.GC 用户程序手动触发垃圾回收
- runtime.mallocgc  申请内存的时候会触发垃圾回收

&emsp;除了使用后台运行的系统监控器和强制垃圾收集助手触发垃圾回收之外，另外两个方法会任意的处理器上触发垃圾收集，这种不需要中心组件的协调在1.6里面引入的。下面展开三种触发方式

**后台触发**
&emsp;运行时会在应用程序启动的时候会在后台开启一个用于强制触发垃圾回收的goroutine, 这个goroutine的指责非常简单，就是调用`gcStart`尝试开启新一轮的垃圾收集
&emsp;本质上是后台sysmon 会定时的通过`gctrigger.test()`来检测是否满足触发条件，如果满足并且当前没有处于强制触发gc，那么这个时候就会去将forcegchelper这个goroutine放到全局调度队列里面开始调度

**手动触发**
&emsp;通过`GC`函数主动触发


**申请内存会触发**
- 当前线程的内存管理单元不存在空闲的空间的时候，创建微小对象和小对象需要调用`runtime.mcache.nextFree()`从中心缓存或者页堆里面获取新的内存管理单元，就会触发垃圾收集
- 当用户程序申请分配32KB 以上的大对象时候，一定会构建`runtime.gcTrigger`结构体尝试触发垃圾收集

&emsp;通过堆内存触发垃圾回收需要比较`runtime.mstats`中的两个字段`heap_live`和`gc_trigger`两个字段，当内存里面存活的对象字节数大于触发垃圾回收收集堆的大小的时候，新的一轮垃圾回收就会触发
- `heap_live`: 为了减少锁竞争，运行时候只会在中心缓存里面分配或者释放内存管理单元以及堆上分配大对象的时候才会更新
- `gc_trigger`: 在标记阶段终止调用`runtime.gcSetTriggerRatio`更新触发下一次垃圾回收的堆大小

&emsp;`runtime.gcController`在标记终止阶段调用`runtime.gcSetTriggerRatio`更新触发下一次垃圾收集堆大小,设置`gc_trigger`它能够决定触发垃圾收集的时间以及用户程序和后台处理标记的任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集CPU利用率确定触发垃圾回收的时机。



#### 垃圾收集启动
&emsp; 垃圾收集启动过程中一定会调用`gcStart`函数，实现很复杂，主要的职责就是负责修改全局垃圾收集状态到`_GCMark`并且做一些准备工作，
- 两次调用`runtime.gcTrigger.test()`函数来检查垃圾收集是否满足收集条件
- 暂停程序，在后台启动用于处理标记任务的工作goroutine,确定所有的的内存单元都被清理了以及其他标记任务的开始准备工作
- 进入扫描阶段，准备后台的标记工作，根对象的标记工作，以及微对象，恢复用户程序，进入并发扫描阶段，和标记阶段


&emsp;在验证完垃圾收集的条件进入收尾工作后，该方法会通过`semacquire`获取全局`worldsema`信号量，调用`runtime.gcBgMarkStartWorkers()`函数启动后台标记任务，在系统栈里面调用`stopTheWorldWithSema`函数来暂停程序调用, 


**后台标记模式**
&emsp;在垃圾收集启动期间，会调用`gcBgMarkStartWorkers`为全局所有的处理器都创建一个用于执行mark任务的goroutine
&emsp;用于并发扫描对象的工作协程goroutine总共有三种工作模式`gcMarkWorkerMode`
- `gcMarkWorkerDedicateMode`: 处理器专门负责标记对象，这个不会被抢占
- `gcMarkWorkerFractionalMode`: 当垃圾收集器的后台CPU使用率达不到预期的时候(默认为25%),启动该类型的工作协程帮忙垃圾收集，以达到CPU利用率的目标，因为它只占用同一个CPU的内部资源。，所以可以被调度。
- `gcMarkWorkerIdleMode`: 当前处理器没有可执行的goroutine的时候，它会运行垃圾收集的标记任务直到被抢占为止。
