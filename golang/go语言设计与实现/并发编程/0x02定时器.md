
#### 0x00 设计原理
&emsp;go语言从实现计时器到现在经历了4个版本
- go1.9之前，所有计时器由一个全局的四叉堆来维护
- go1.10-1.13, 全局使用64个四叉堆维护全部的计时器，每个处理器(P)都会由对应的四叉堆来维护
- go1.14 以后版本，每个处理器单独管理计时器，并且通过网络轮询器触发
> 这章节会分别介绍计时器在不通版本里面的设计，梳理计时器的演进过程。

**最小四叉堆**
&emsp;在四叉堆里面,有全局锁的问题，导致性能差

**分片四叉堆**
&emsp;全局64个四叉堆，当cpu超过64个的时候也会存在问题

**网络轮询器**
&emsp;在新版本里面计时器桶已经被移除了，所有的计时器都是以四叉堆的形式存储在处理器`runtime.p`里面, 处理器里面和计时器相关的字段如下:
```go 
type p struct {
	...
	timersLock mutex
	timers []*timer

	numTimers     uint32
	adjustTimers  uint32
	deletedTimers uint32
	...
}
```
- `timersLock`: 保护计时器的互斥锁
- `timers`:     存储计时器的最小四叉堆
- `numTimers`:  处理器中计时器数量
- `adjustTimers`:   处理器中处于`timerModifiedEarlier`状态的计时器数量
- `deletedTimers`:  处理器中处于`timerDeleted`状态的计时器的数量
> 目前计时器都交给网络轮询器和调度器触发，这种方式能够充分利用本地性，减少上下文的开销。


#### 0x01 计时器数据结构
&emsp;`runtime.timer`是go里面计时器内部的表示，每个计时器都存储在对应处理器的最小四叉堆里面
```go 
type timer struct {
	pp puintptr

	when     int64
	period   int64
	f        func(interface{}, uintptr)
	arg      interface{}
	seq      uintptr
	nextwhen int64
	status   uint32
}
```
- `when`：  当前计时器被唤醒的时间
- `period`： 两次被唤醒的时间间隔
- `f`： 每当计时器被唤醒的时候调用的函数
- `arg`: 计时器被唤醒的时候调用f传入的参数
- `nextWhen` 计时器处于`timerModifiedXX` 状态时，用于设置`when`字段
- `status` 计时器的状态
> 这里`runtime.timer` 只是计时器运行时的私有结构体，对外暴露计时器使用的结构体如下:
```go 
type Timer struct {
    C <- chan Time
    r runtimeTimer
}
```
> `timer.Timer`计时器必须通过`time.NewTimer， time.AfterFunc, time.After`函数创建，当计时器失效的时，订阅纪计时器Channel的goroutine会收到计时器失效的时间.


#### 0x02 触发计时器
&emsp;在go里面有两个模块会触发计时器，运行计时器里面保存的函数：
- 调度器调度时会检查处理器里面的计时器是否准备就绪了
- 系统监控会检查是否有未执行的到期计时器
> 下面将会分析上述两个触发过程

**调度器**
&emsp;`runtime.checkTimers`是调度器用来运行处理器中计时器的函数，它会在以下三种情况下被触发:
- 调度器调用`runtime.schedule`执行调度的时候
- 调度器调用`runtime.finderunnable`获取可执行的`goroutine`的时候
- 调度器调用`runtime.findrunnable`从其他处理器窃取计时器的时候
&emsp;这里分析下`runtime.checkTimers`的实现，我们将该函数的实现分成调整计时器，运行计时器，和删除计时器三个部分。首先调整堆中计时器的过程。



**系统监控**
