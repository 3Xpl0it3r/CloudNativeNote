
#### 0x00 基本原语
&emsp;`go`在`sync`提供了一些用于同步的一些基本原语，包括常见的`sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Cond`这些原语提供了较为基础的功能，但是也是一种相对原始的同步机制，大多数情况下，更应该使用抽象层级更高的channel来实现同步。


**Mutex**
&emsp;`go`语言里面的`sync.Mutex`有两个字段`state`和`sema`，其中`state`表示当前互斥锁的状态，而`sema`则是用于控制锁状态的信号量。
```go 
// A Mutex is a mutual exclusion lock.
// The zero value for a Mutex is an unlocked mutex.
//
// A Mutex must not be copied after first use.
type Mutex struct {
	state int32
	sema  uint32
}
```

**状态**
&emsp;互斥锁的状态比较复杂，
`| waiterCount |  starving | woken | locked |`
> 最低三位分别表示 `mutexLocked, mutexWoken, mutexStarving`, 剩下的表示有多少个grouting在等待。总共占据4个字节，总共有32位

&emsp;在默认的情况下，互斥锁的所有状态都是0， int32的不同位分别表示不同的状态
- `mutexLocked` - 表示互斥锁的锁定状态
- `mutextWoken` - 表示从正常模式被唤醒
- `mutexStarving` - 当前的互斥锁进入饥饿状态
- `waiterCount` - 当前互斥锁上等待的`Goroutine`的数量


**正常模式和饥饿模式**
&emsp;`sync.Mutex` 有两种模式： 正常模式和饥饿模式， 我们需要了解正常模式和饥饿模式都是什么，以及他们是什么关系。
&emsp;正常模式下，锁的等待着会按照先进先出的顺序获取，但是刚被唤起的`goroutine`与新建的`goroutine`竞争的时候，大概率会获取不到锁，为了减少这种情况一旦goroutine超过1ms没有获取到锁，它就会将当前互斥锁切换为饥饿模式，防止部分goroutine 被饿死。

&emsp;饥饿模式(starving) 锁是在go1.9里面引入优化，引入饥饿模式的是为了保证互斥锁的公平性。在饥饿模式下，互斥锁会直接交给等待队列最前面的goroutine, 新建的`goroutine`无法获得锁，也无法进入自旋模式。他们只会在队列的末尾等待。 如果一个`goroutine`他获得了互斥锁并且他在队列的末尾或者等待的时间少于1ms, 那么互斥锁就会进入正常模式。

> 与饥饿模式相比，正常模式下的互斥锁能够提供更好的性能，饥饿模式的能够避免goroutine由于选入等待无法获得锁造成高尾延迟时。


**加锁和解锁**
&emsp;我们在这个章节里面分别介绍互斥锁的枷锁和解锁过程。他们分别使用`sync.Mutex.Lock`和`sync.Mutex.Unlick`方法。
&emsp;互斥锁的枷锁是靠`sync.Mutex.Lock`完成的，方法进行了简化，方法的主干只保留了最常见的，最简单的情况，- 当锁的状态为0 的时候，将`mutexLocked`设置为1
```go 
const 	mutexLocked = 1 << iota 
/ Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
	// Fast path: grab unlocked mutex.
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
		if race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		return
	}
	// Slow path (outlined so that the fast path can be inlined)
	m.lockSlow()
}
```
&emsp;如果锁不是为0，那么就会调用`sync.Mutex.lockSlow`尝试通过自旋等方式等待锁释放, 该方法的主体是一大的循环，下面将它分成几个部分介绍获取锁的过程:
- 判断当前goroutine 能否进入自旋
- 通过自旋等待互斥的最新状态
- 计算互斥锁的最新状态
- 更新互斥锁的状态并且获取锁

&emsp;自旋是一种多线程的同步机制，当进程在进入自旋的的过程中会一直保持这cpu的占用，持续检查某个条件是否满足为真。在多核CPU上面，自旋可以避免goroutine的切换，使用恰当会对性能有提升，但是使用不当会拖慢整个程序的性能，所以goroutine进入自旋的条件非常苛刻:
- 互斥锁只有在普通模式才能进入自旋
- `runtime_sync_runtime_canSpin`需要返回true。
- - 运行在多个CPU的机器上
- - 当前gorouine 为了获取锁进入自旋的次数小于4次
- - 当前机器上至少存在一个正在运行的处理器P，并且处理的队列为空。

